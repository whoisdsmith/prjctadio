/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NotesMergerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/views/notes-merger.ts
var import_obsidian6 = require("obsidian");

// src/views/generate-latex.ts
var fs = __toESM(require("fs"));
var Path = __toESM(require("path"));
var import_obsidian4 = require("obsidian");

// node_modules/mdast-util-to-string/lib/index.js
var emptyOptions = {};
function toString(value, options) {
  const settings = options || emptyOptions;
  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
  return one(value, includeImageAlt, includeHtml);
}
function one(value, includeImageAlt, includeHtml) {
  if (node(value)) {
    if ("value" in value) {
      return value.type === "html" && !includeHtml ? "" : value.value;
    }
    if (includeImageAlt && "alt" in value && value.alt) {
      return value.alt;
    }
    if ("children" in value) {
      return all(value.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value)) {
    return all(value, includeImageAlt, includeHtml);
  }
  return "";
}
function all(values, includeImageAlt, includeHtml) {
  const result = [];
  let index2 = -1;
  while (++index2 < values.length) {
    result[index2] = one(values[index2], includeImageAlt, includeHtml);
  }
  return result.join("");
}
function node(value) {
  return Boolean(value && typeof value === "object");
}

// node_modules/decode-named-character-reference/index.dom.js
var element = document.createElement("i");
function decodeNamedCharacterReference(value) {
  const characterReference2 = "&" + value + ";";
  element.innerHTML = characterReference2;
  const char = element.textContent;
  if (char.charCodeAt(char.length - 1) === 59 && value !== "semi") {
    return false;
  }
  return char === characterReference2 ? false : char;
}

// node_modules/micromark-util-chunked/index.js
function splice(list2, start, remove, items) {
  const end = list2.length;
  let chunkStart = 0;
  let parameters;
  if (start < 0) {
    start = -start > end ? 0 : end + start;
  } else {
    start = start > end ? end : start;
  }
  remove = remove > 0 ? remove : 0;
  if (items.length < 1e4) {
    parameters = Array.from(items);
    parameters.unshift(start, remove);
    list2.splice(...parameters);
  } else {
    if (remove)
      list2.splice(start, remove);
    while (chunkStart < items.length) {
      parameters = items.slice(chunkStart, chunkStart + 1e4);
      parameters.unshift(start, 0);
      list2.splice(...parameters);
      chunkStart += 1e4;
      start += 1e4;
    }
  }
}
function push(list2, items) {
  if (list2.length > 0) {
    splice(list2, list2.length, 0, items);
    return list2;
  }
  return items;
}

// node_modules/micromark-util-combine-extensions/index.js
var hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all2 = {};
  let index2 = -1;
  while (++index2 < extensions.length) {
    syntaxExtension(all2, extensions[index2]);
  }
  return all2;
}
function syntaxExtension(all2, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty.call(all2, hook) ? all2[hook] : void 0;
    const left = maybe || (all2[hook] = {});
    const right = extension2[hook];
    let code;
    if (right) {
      for (code in right) {
        if (!hasOwnProperty.call(left, code))
          left[code] = [];
        const value = right[code];
        constructs(left[code], Array.isArray(value) ? value : value ? [value] : []);
      }
    }
  }
}
function constructs(existing, list2) {
  let index2 = -1;
  const before = [];
  while (++index2 < list2.length) {
    ;
    (list2[index2].add === "after" ? existing : before).push(list2[index2]);
  }
  splice(existing, 0, 0, before);
}

// node_modules/micromark-util-decode-numeric-character-reference/index.js
function decodeNumericCharacterReference(value, base) {
  const code = Number.parseInt(value, base);
  if (code < 9 || code === 11 || code > 13 && code < 32 || code > 126 && code < 160 || code > 55295 && code < 57344 || code > 64975 && code < 65008 || (code & 65535) === 65535 || (code & 65535) === 65534 || code > 1114111) {
    return "\uFFFD";
  }
  return String.fromCodePoint(code);
}

// node_modules/micromark-util-normalize-identifier/index.js
function normalizeIdentifier(value) {
  return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}

// node_modules/micromark-util-character/index.js
var unicodePunctuationInternal = regexCheck(/\p{P}/u);
var asciiAlpha = regexCheck(/[A-Za-z]/);
var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code) {
  return code !== null && (code < 32 || code === 127);
}
var asciiDigit = regexCheck(/\d/);
var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(code) {
  return code !== null && code < -2;
}
function markdownLineEndingOrSpace(code) {
  return code !== null && (code < 0 || code === 32);
}
function markdownSpace(code) {
  return code === -2 || code === -1 || code === 32;
}
function unicodePunctuation(code) {
  return asciiPunctuation(code) || unicodePunctuationInternal(code);
}
var unicodeWhitespace = regexCheck(/\s/);
function regexCheck(regex) {
  return check;
  function check(code) {
    return code !== null && code > -1 && regex.test(String.fromCharCode(code));
  }
}

// node_modules/micromark-factory-space/index.js
function factorySpace(effects, ok, type, max) {
  const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
  let size = 0;
  return start;
  function start(code) {
    if (markdownSpace(code)) {
      effects.enter(type);
      return prefix(code);
    }
    return ok(code);
  }
  function prefix(code) {
    if (markdownSpace(code) && size++ < limit) {
      effects.consume(code);
      return prefix;
    }
    effects.exit(type);
    return ok(code);
  }
}

// node_modules/micromark/lib/initialize/content.js
var content = {
  tokenize: initializeContent
};
function initializeContent(effects) {
  const contentStart = effects.attempt(this.parser.constructs.contentInitial, afterContentStartConstruct, paragraphInitial);
  let previous2;
  return contentStart;
  function afterContentStartConstruct(code) {
    if (code === null) {
      effects.consume(code);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code);
    effects.exit("lineEnding");
    return factorySpace(effects, contentStart, "linePrefix");
  }
  function paragraphInitial(code) {
    effects.enter("paragraph");
    return lineStart(code);
  }
  function lineStart(code) {
    const token = effects.enter("chunkText", {
      contentType: "text",
      previous: previous2
    });
    if (previous2) {
      previous2.next = token;
    }
    previous2 = token;
    return data(code);
  }
  function data(code) {
    if (code === null) {
      effects.exit("chunkText");
      effects.exit("paragraph");
      effects.consume(code);
      return;
    }
    if (markdownLineEnding(code)) {
      effects.consume(code);
      effects.exit("chunkText");
      return lineStart;
    }
    effects.consume(code);
    return data;
  }
}

// node_modules/micromark/lib/initialize/document.js
var document2 = {
  tokenize: initializeDocument
};
var containerConstruct = {
  tokenize: tokenizeContainer
};
function initializeDocument(effects) {
  const self = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start;
  function start(code) {
    if (continued < stack.length) {
      const item = stack[continued];
      self.containerState = item[1];
      return effects.attempt(item[0].continuation, documentContinue, checkNewContainers)(code);
    }
    return checkNewContainers(code);
  }
  function documentContinue(code) {
    continued++;
    if (self.containerState._closeFlow) {
      self.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point3;
      while (indexBeforeFlow--) {
        if (self.events[indexBeforeFlow][0] === "exit" && self.events[indexBeforeFlow][1].type === "chunkFlow") {
          point3 = self.events[indexBeforeFlow][1].end;
          break;
        }
      }
      exitContainers(continued);
      let index2 = indexBeforeExits;
      while (index2 < self.events.length) {
        self.events[index2][1].end = Object.assign({}, point3);
        index2++;
      }
      splice(self.events, indexBeforeFlow + 1, 0, self.events.slice(indexBeforeExits));
      self.events.length = index2;
      return checkNewContainers(code);
    }
    return start(code);
  }
  function checkNewContainers(code) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code);
      }
      self.interrupt = Boolean(childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack);
    }
    self.containerState = {};
    return effects.check(containerConstruct, thereIsANewContainer, thereIsNoNewContainer)(code);
  }
  function thereIsANewContainer(code) {
    if (childFlow)
      closeFlow();
    exitContainers(continued);
    return documentContinued(code);
  }
  function thereIsNoNewContainer(code) {
    self.parser.lazy[self.now().line] = continued !== stack.length;
    lineStartOffset = self.now().offset;
    return flowStart(code);
  }
  function documentContinued(code) {
    self.containerState = {};
    return effects.attempt(containerConstruct, containerContinue, flowStart)(code);
  }
  function containerContinue(code) {
    continued++;
    stack.push([self.currentConstruct, self.containerState]);
    return documentContinued(code);
  }
  function flowStart(code) {
    if (code === null) {
      if (childFlow)
        closeFlow();
      exitContainers(0);
      effects.consume(code);
      return;
    }
    childFlow = childFlow || self.parser.flow(self.now());
    effects.enter("chunkFlow", {
      contentType: "flow",
      previous: childToken,
      _tokenizer: childFlow
    });
    return flowContinue(code);
  }
  function flowContinue(code) {
    if (code === null) {
      writeToChild(effects.exit("chunkFlow"), true);
      exitContainers(0);
      effects.consume(code);
      return;
    }
    if (markdownLineEnding(code)) {
      effects.consume(code);
      writeToChild(effects.exit("chunkFlow"));
      continued = 0;
      self.interrupt = void 0;
      return start;
    }
    effects.consume(code);
    return flowContinue;
  }
  function writeToChild(token, eof) {
    const stream = self.sliceStream(token);
    if (eof)
      stream.push(null);
    token.previous = childToken;
    if (childToken)
      childToken.next = token;
    childToken = token;
    childFlow.defineSkip(token.start);
    childFlow.write(stream);
    if (self.parser.lazy[token.start.line]) {
      let index2 = childFlow.events.length;
      while (index2--) {
        if (childFlow.events[index2][1].start.offset < lineStartOffset && (!childFlow.events[index2][1].end || childFlow.events[index2][1].end.offset > lineStartOffset)) {
          return;
        }
      }
      const indexBeforeExits = self.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen;
      let point3;
      while (indexBeforeFlow--) {
        if (self.events[indexBeforeFlow][0] === "exit" && self.events[indexBeforeFlow][1].type === "chunkFlow") {
          if (seen) {
            point3 = self.events[indexBeforeFlow][1].end;
            break;
          }
          seen = true;
        }
      }
      exitContainers(continued);
      index2 = indexBeforeExits;
      while (index2 < self.events.length) {
        self.events[index2][1].end = Object.assign({}, point3);
        index2++;
      }
      splice(self.events, indexBeforeFlow + 1, 0, self.events.slice(indexBeforeExits));
      self.events.length = index2;
    }
  }
  function exitContainers(size) {
    let index2 = stack.length;
    while (index2-- > size) {
      const entry = stack[index2];
      self.containerState = entry[1];
      entry[0].exit.call(self, effects);
    }
    stack.length = size;
  }
  function closeFlow() {
    childFlow.write([null]);
    childToken = void 0;
    childFlow = void 0;
    self.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok, nok) {
  return factorySpace(effects, effects.attempt(this.parser.constructs.document, ok, nok), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}

// node_modules/micromark-util-classify-character/index.js
function classifyCharacter(code) {
  if (code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {
    return 1;
  }
  if (unicodePunctuation(code)) {
    return 2;
  }
}

// node_modules/micromark-util-resolve-all/index.js
function resolveAll(constructs2, events, context) {
  const called = [];
  let index2 = -1;
  while (++index2 < constructs2.length) {
    const resolve = constructs2[index2].resolveAll;
    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context);
      called.push(resolve);
    }
  }
  return events;
}

// node_modules/micromark-core-commonmark/lib/attention.js
var attention = {
  name: "attention",
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
};
function resolveAllAttention(events, context) {
  let index2 = -1;
  let open;
  let group;
  let text3;
  let openingSequence;
  let closingSequence;
  let use;
  let nextEvents;
  let offset;
  while (++index2 < events.length) {
    if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
      open = index2;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
            continue;
          }
          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
          const start = Object.assign({}, events[open][1].end);
          const end = Object.assign({}, events[index2][1].start);
          movePoint(start, -use);
          movePoint(end, use);
          openingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start,
            end: Object.assign({}, events[open][1].end)
          };
          closingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, events[index2][1].start),
            end
          };
          text3 = {
            type: use > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, events[open][1].end),
            end: Object.assign({}, events[index2][1].start)
          };
          group = {
            type: use > 1 ? "strong" : "emphasis",
            start: Object.assign({}, openingSequence.start),
            end: Object.assign({}, closingSequence.end)
          };
          events[open][1].end = Object.assign({}, openingSequence.start);
          events[index2][1].start = Object.assign({}, closingSequence.end);
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push(nextEvents, [
              ["enter", events[open][1], context],
              ["exit", events[open][1], context]
            ]);
          }
          nextEvents = push(nextEvents, [
            ["enter", group, context],
            ["enter", openingSequence, context],
            ["exit", openingSequence, context],
            ["enter", text3, context]
          ]);
          nextEvents = push(nextEvents, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index2), context));
          nextEvents = push(nextEvents, [
            ["exit", text3, context],
            ["enter", closingSequence, context],
            ["exit", closingSequence, context],
            ["exit", group, context]
          ]);
          if (events[index2][1].end.offset - events[index2][1].start.offset) {
            offset = 2;
            nextEvents = push(nextEvents, [
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context]
            ]);
          } else {
            offset = 0;
          }
          splice(events, open - 1, index2 - open + 3, nextEvents);
          index2 = open + nextEvents.length - offset - 2;
          break;
        }
      }
    }
  }
  index2 = -1;
  while (++index2 < events.length) {
    if (events[index2][1].type === "attentionSequence") {
      events[index2][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous2 = this.previous;
  const before = classifyCharacter(previous2);
  let marker;
  return start;
  function start(code) {
    marker = code;
    effects.enter("attentionSequence");
    return inside(code);
  }
  function inside(code) {
    if (code === marker) {
      effects.consume(code);
      return inside;
    }
    const token = effects.exit("attentionSequence");
    const after = classifyCharacter(code);
    const open = !after || after === 2 && before || attentionMarkers2.includes(code);
    const close = !before || before === 2 && after || attentionMarkers2.includes(previous2);
    token._open = Boolean(marker === 42 ? open : open && (before || !close));
    token._close = Boolean(marker === 42 ? close : close && (after || !open));
    return ok(code);
  }
}
function movePoint(point3, offset) {
  point3.column += offset;
  point3.offset += offset;
  point3._bufferIndex += offset;
}

// node_modules/micromark-core-commonmark/lib/autolink.js
var autolink = {
  name: "autolink",
  tokenize: tokenizeAutolink
};
function tokenizeAutolink(effects, ok, nok) {
  let size = 0;
  return start;
  function start(code) {
    effects.enter("autolink");
    effects.enter("autolinkMarker");
    effects.consume(code);
    effects.exit("autolinkMarker");
    effects.enter("autolinkProtocol");
    return open;
  }
  function open(code) {
    if (asciiAlpha(code)) {
      effects.consume(code);
      return schemeOrEmailAtext;
    }
    return emailAtext(code);
  }
  function schemeOrEmailAtext(code) {
    if (code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)) {
      size = 1;
      return schemeInsideOrEmailAtext(code);
    }
    return emailAtext(code);
  }
  function schemeInsideOrEmailAtext(code) {
    if (code === 58) {
      effects.consume(code);
      size = 0;
      return urlInside;
    }
    if ((code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)) && size++ < 32) {
      effects.consume(code);
      return schemeInsideOrEmailAtext;
    }
    size = 0;
    return emailAtext(code);
  }
  function urlInside(code) {
    if (code === 62) {
      effects.exit("autolinkProtocol");
      effects.enter("autolinkMarker");
      effects.consume(code);
      effects.exit("autolinkMarker");
      effects.exit("autolink");
      return ok;
    }
    if (code === null || code === 32 || code === 60 || asciiControl(code)) {
      return nok(code);
    }
    effects.consume(code);
    return urlInside;
  }
  function emailAtext(code) {
    if (code === 64) {
      effects.consume(code);
      return emailAtSignOrDot;
    }
    if (asciiAtext(code)) {
      effects.consume(code);
      return emailAtext;
    }
    return nok(code);
  }
  function emailAtSignOrDot(code) {
    return asciiAlphanumeric(code) ? emailLabel(code) : nok(code);
  }
  function emailLabel(code) {
    if (code === 46) {
      effects.consume(code);
      size = 0;
      return emailAtSignOrDot;
    }
    if (code === 62) {
      effects.exit("autolinkProtocol").type = "autolinkEmail";
      effects.enter("autolinkMarker");
      effects.consume(code);
      effects.exit("autolinkMarker");
      effects.exit("autolink");
      return ok;
    }
    return emailValue(code);
  }
  function emailValue(code) {
    if ((code === 45 || asciiAlphanumeric(code)) && size++ < 63) {
      const next = code === 45 ? emailValue : emailLabel;
      effects.consume(code);
      return next;
    }
    return nok(code);
  }
}

// node_modules/micromark-core-commonmark/lib/blank-line.js
var blankLine = {
  tokenize: tokenizeBlankLine,
  partial: true
};
function tokenizeBlankLine(effects, ok, nok) {
  return start;
  function start(code) {
    return markdownSpace(code) ? factorySpace(effects, after, "linePrefix")(code) : after(code);
  }
  function after(code) {
    return code === null || markdownLineEnding(code) ? ok(code) : nok(code);
  }
}

// node_modules/micromark-core-commonmark/lib/block-quote.js
var blockQuote = {
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart,
  continuation: {
    tokenize: tokenizeBlockQuoteContinuation
  },
  exit
};
function tokenizeBlockQuoteStart(effects, ok, nok) {
  const self = this;
  return start;
  function start(code) {
    if (code === 62) {
      const state = self.containerState;
      if (!state.open) {
        effects.enter("blockQuote", {
          _container: true
        });
        state.open = true;
      }
      effects.enter("blockQuotePrefix");
      effects.enter("blockQuoteMarker");
      effects.consume(code);
      effects.exit("blockQuoteMarker");
      return after;
    }
    return nok(code);
  }
  function after(code) {
    if (markdownSpace(code)) {
      effects.enter("blockQuotePrefixWhitespace");
      effects.consume(code);
      effects.exit("blockQuotePrefixWhitespace");
      effects.exit("blockQuotePrefix");
      return ok;
    }
    effects.exit("blockQuotePrefix");
    return ok(code);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok, nok) {
  const self = this;
  return contStart;
  function contStart(code) {
    if (markdownSpace(code)) {
      return factorySpace(effects, contBefore, "linePrefix", self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code);
    }
    return contBefore(code);
  }
  function contBefore(code) {
    return effects.attempt(blockQuote, ok, nok)(code);
  }
}
function exit(effects) {
  effects.exit("blockQuote");
}

// node_modules/micromark-core-commonmark/lib/character-escape.js
var characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok, nok) {
  return start;
  function start(code) {
    effects.enter("characterEscape");
    effects.enter("escapeMarker");
    effects.consume(code);
    effects.exit("escapeMarker");
    return inside;
  }
  function inside(code) {
    if (asciiPunctuation(code)) {
      effects.enter("characterEscapeValue");
      effects.consume(code);
      effects.exit("characterEscapeValue");
      effects.exit("characterEscape");
      return ok;
    }
    return nok(code);
  }
}

// node_modules/micromark-core-commonmark/lib/character-reference.js
var characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok, nok) {
  const self = this;
  let size = 0;
  let max;
  let test;
  return start;
  function start(code) {
    effects.enter("characterReference");
    effects.enter("characterReferenceMarker");
    effects.consume(code);
    effects.exit("characterReferenceMarker");
    return open;
  }
  function open(code) {
    if (code === 35) {
      effects.enter("characterReferenceMarkerNumeric");
      effects.consume(code);
      effects.exit("characterReferenceMarkerNumeric");
      return numeric;
    }
    effects.enter("characterReferenceValue");
    max = 31;
    test = asciiAlphanumeric;
    return value(code);
  }
  function numeric(code) {
    if (code === 88 || code === 120) {
      effects.enter("characterReferenceMarkerHexadecimal");
      effects.consume(code);
      effects.exit("characterReferenceMarkerHexadecimal");
      effects.enter("characterReferenceValue");
      max = 6;
      test = asciiHexDigit;
      return value;
    }
    effects.enter("characterReferenceValue");
    max = 7;
    test = asciiDigit;
    return value(code);
  }
  function value(code) {
    if (code === 59 && size) {
      const token = effects.exit("characterReferenceValue");
      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self.sliceSerialize(token))) {
        return nok(code);
      }
      effects.enter("characterReferenceMarker");
      effects.consume(code);
      effects.exit("characterReferenceMarker");
      effects.exit("characterReference");
      return ok;
    }
    if (test(code) && size++ < max) {
      effects.consume(code);
      return value;
    }
    return nok(code);
  }
}

// node_modules/micromark-core-commonmark/lib/code-fenced.js
var nonLazyContinuation = {
  tokenize: tokenizeNonLazyContinuation,
  partial: true
};
var codeFenced = {
  name: "codeFenced",
  tokenize: tokenizeCodeFenced,
  concrete: true
};
function tokenizeCodeFenced(effects, ok, nok) {
  const self = this;
  const closeStart = {
    tokenize: tokenizeCloseStart,
    partial: true
  };
  let initialPrefix = 0;
  let sizeOpen = 0;
  let marker;
  return start;
  function start(code) {
    return beforeSequenceOpen(code);
  }
  function beforeSequenceOpen(code) {
    const tail = self.events[self.events.length - 1];
    initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
    marker = code;
    effects.enter("codeFenced");
    effects.enter("codeFencedFence");
    effects.enter("codeFencedFenceSequence");
    return sequenceOpen(code);
  }
  function sequenceOpen(code) {
    if (code === marker) {
      sizeOpen++;
      effects.consume(code);
      return sequenceOpen;
    }
    if (sizeOpen < 3) {
      return nok(code);
    }
    effects.exit("codeFencedFenceSequence");
    return markdownSpace(code) ? factorySpace(effects, infoBefore, "whitespace")(code) : infoBefore(code);
  }
  function infoBefore(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit("codeFencedFence");
      return self.interrupt ? ok(code) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code);
    }
    effects.enter("codeFencedFenceInfo");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return info(code);
  }
  function info(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return infoBefore(code);
    }
    if (markdownSpace(code)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return factorySpace(effects, metaBefore, "whitespace")(code);
    }
    if (code === 96 && code === marker) {
      return nok(code);
    }
    effects.consume(code);
    return info;
  }
  function metaBefore(code) {
    if (code === null || markdownLineEnding(code)) {
      return infoBefore(code);
    }
    effects.enter("codeFencedFenceMeta");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return meta(code);
  }
  function meta(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceMeta");
      return infoBefore(code);
    }
    if (code === 96 && code === marker) {
      return nok(code);
    }
    effects.consume(code);
    return meta;
  }
  function atNonLazyBreak(code) {
    return effects.attempt(closeStart, after, contentBefore)(code);
  }
  function contentBefore(code) {
    effects.enter("lineEnding");
    effects.consume(code);
    effects.exit("lineEnding");
    return contentStart;
  }
  function contentStart(code) {
    return initialPrefix > 0 && markdownSpace(code) ? factorySpace(effects, beforeContentChunk, "linePrefix", initialPrefix + 1)(code) : beforeContentChunk(code);
  }
  function beforeContentChunk(code) {
    if (code === null || markdownLineEnding(code)) {
      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code);
    }
    effects.enter("codeFlowValue");
    return contentChunk(code);
  }
  function contentChunk(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit("codeFlowValue");
      return beforeContentChunk(code);
    }
    effects.consume(code);
    return contentChunk;
  }
  function after(code) {
    effects.exit("codeFenced");
    return ok(code);
  }
  function tokenizeCloseStart(effects2, ok2, nok2) {
    let size = 0;
    return startBefore;
    function startBefore(code) {
      effects2.enter("lineEnding");
      effects2.consume(code);
      effects2.exit("lineEnding");
      return start2;
    }
    function start2(code) {
      effects2.enter("codeFencedFence");
      return markdownSpace(code) ? factorySpace(effects2, beforeSequenceClose, "linePrefix", self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code) : beforeSequenceClose(code);
    }
    function beforeSequenceClose(code) {
      if (code === marker) {
        effects2.enter("codeFencedFenceSequence");
        return sequenceClose(code);
      }
      return nok2(code);
    }
    function sequenceClose(code) {
      if (code === marker) {
        size++;
        effects2.consume(code);
        return sequenceClose;
      }
      if (size >= sizeOpen) {
        effects2.exit("codeFencedFenceSequence");
        return markdownSpace(code) ? factorySpace(effects2, sequenceCloseAfter, "whitespace")(code) : sequenceCloseAfter(code);
      }
      return nok2(code);
    }
    function sequenceCloseAfter(code) {
      if (code === null || markdownLineEnding(code)) {
        effects2.exit("codeFencedFence");
        return ok2(code);
      }
      return nok2(code);
    }
  }
}
function tokenizeNonLazyContinuation(effects, ok, nok) {
  const self = this;
  return start;
  function start(code) {
    if (code === null) {
      return nok(code);
    }
    effects.enter("lineEnding");
    effects.consume(code);
    effects.exit("lineEnding");
    return lineStart;
  }
  function lineStart(code) {
    return self.parser.lazy[self.now().line] ? nok(code) : ok(code);
  }
}

// node_modules/micromark-core-commonmark/lib/code-indented.js
var codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
var furtherStart = {
  tokenize: tokenizeFurtherStart,
  partial: true
};
function tokenizeCodeIndented(effects, ok, nok) {
  const self = this;
  return start;
  function start(code) {
    effects.enter("codeIndented");
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code);
  }
  function afterPrefix(code) {
    const tail = self.events[self.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? atBreak(code) : nok(code);
  }
  function atBreak(code) {
    if (code === null) {
      return after(code);
    }
    if (markdownLineEnding(code)) {
      return effects.attempt(furtherStart, atBreak, after)(code);
    }
    effects.enter("codeFlowValue");
    return inside(code);
  }
  function inside(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit("codeFlowValue");
      return atBreak(code);
    }
    effects.consume(code);
    return inside;
  }
  function after(code) {
    effects.exit("codeIndented");
    return ok(code);
  }
}
function tokenizeFurtherStart(effects, ok, nok) {
  const self = this;
  return furtherStart2;
  function furtherStart2(code) {
    if (self.parser.lazy[self.now().line]) {
      return nok(code);
    }
    if (markdownLineEnding(code)) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return furtherStart2;
    }
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code);
  }
  function afterPrefix(code) {
    const tail = self.events[self.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok(code) : markdownLineEnding(code) ? furtherStart2(code) : nok(code);
  }
}

// node_modules/micromark-core-commonmark/lib/code-text.js
var codeText = {
  name: "codeText",
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index2;
  let enter;
  if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
    index2 = headEnterIndex;
    while (++index2 < tailExitIndex) {
      if (events[index2][1].type === "codeTextData") {
        events[headEnterIndex][1].type = "codeTextPadding";
        events[tailExitIndex][1].type = "codeTextPadding";
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index2 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index2 <= tailExitIndex) {
    if (enter === void 0) {
      if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
        enter = index2;
      }
    } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
      events[enter][1].type = "codeTextData";
      if (index2 !== enter + 2) {
        events[enter][1].end = events[index2 - 1][1].end;
        events.splice(enter + 2, index2 - enter - 2);
        tailExitIndex -= index2 - enter - 2;
        index2 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous(code) {
  return code !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeCodeText(effects, ok, nok) {
  const self = this;
  let sizeOpen = 0;
  let size;
  let token;
  return start;
  function start(code) {
    effects.enter("codeText");
    effects.enter("codeTextSequence");
    return sequenceOpen(code);
  }
  function sequenceOpen(code) {
    if (code === 96) {
      effects.consume(code);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit("codeTextSequence");
    return between(code);
  }
  function between(code) {
    if (code === null) {
      return nok(code);
    }
    if (code === 32) {
      effects.enter("space");
      effects.consume(code);
      effects.exit("space");
      return between;
    }
    if (code === 96) {
      token = effects.enter("codeTextSequence");
      size = 0;
      return sequenceClose(code);
    }
    if (markdownLineEnding(code)) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return between;
    }
    effects.enter("codeTextData");
    return data(code);
  }
  function data(code) {
    if (code === null || code === 32 || code === 96 || markdownLineEnding(code)) {
      effects.exit("codeTextData");
      return between(code);
    }
    effects.consume(code);
    return data;
  }
  function sequenceClose(code) {
    if (code === 96) {
      effects.consume(code);
      size++;
      return sequenceClose;
    }
    if (size === sizeOpen) {
      effects.exit("codeTextSequence");
      effects.exit("codeText");
      return ok(code);
    }
    token.type = "codeTextData";
    return data(code);
  }
}

// node_modules/micromark-util-subtokenize/index.js
function subtokenize(events) {
  const jumps = {};
  let index2 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  while (++index2 < events.length) {
    while (index2 in jumps) {
      index2 = jumps[index2];
    }
    event = events[index2];
    if (index2 && event[1].type === "chunkFlow" && events[index2 - 1][1].type === "listItemPrefix") {
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === "content") {
            break;
          }
          if (subevents[otherIndex][1].type === "chunkText") {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index2));
        index2 = jumps[index2];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index2;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events[otherIndex];
        if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events[lineIndex][1].type = "lineEndingBlank";
            }
            otherEvent[1].type = "lineEnding";
            lineIndex = otherIndex;
          }
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = Object.assign({}, events[lineIndex][1].start);
        parameters = events.slice(lineIndex, index2);
        parameters.unshift(event);
        splice(events, lineIndex, index2 - lineIndex + 1, parameters);
      }
    }
  }
  return !more;
}
function subcontent(events, eventIndex) {
  const token = events[eventIndex][1];
  const context = events[eventIndex][2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  const tokenizer = token._tokenizer || context.parser[token.contentType](token.start);
  const childEvents = tokenizer.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous2;
  let index2 = -1;
  let current = token;
  let adjust = 0;
  let start = 0;
  const breaks = [start];
  while (current) {
    while (events[++startPosition][1] !== current) {
    }
    startPositions.push(startPosition);
    if (!current._tokenizer) {
      stream = context.sliceStream(current);
      if (!current.next) {
        stream.push(null);
      }
      if (previous2) {
        tokenizer.defineSkip(current.start);
      }
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer.write(stream);
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous2 = current;
    current = current.next;
  }
  current = token;
  while (++index2 < childEvents.length) {
    if (childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line) {
      start = index2 + 1;
      breaks.push(start);
      current._tokenizer = void 0;
      current.previous = void 0;
      current = current.next;
    }
  }
  tokenizer.events = [];
  if (current) {
    current._tokenizer = void 0;
    current.previous = void 0;
  } else {
    breaks.pop();
  }
  index2 = breaks.length;
  while (index2--) {
    const slice = childEvents.slice(breaks[index2], breaks[index2 + 1]);
    const start2 = startPositions.pop();
    jumps.unshift([start2, start2 + slice.length - 1]);
    splice(events, start2, 2, slice);
  }
  index2 = -1;
  while (++index2 < jumps.length) {
    gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
    adjust += jumps[index2][1] - jumps[index2][0] - 1;
  }
  return gaps;
}

// node_modules/micromark-core-commonmark/lib/content.js
var content2 = {
  tokenize: tokenizeContent,
  resolve: resolveContent
};
var continuationConstruct = {
  tokenize: tokenizeContinuation,
  partial: true
};
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok) {
  let previous2;
  return chunkStart;
  function chunkStart(code) {
    effects.enter("content");
    previous2 = effects.enter("chunkContent", {
      contentType: "content"
    });
    return chunkInside(code);
  }
  function chunkInside(code) {
    if (code === null) {
      return contentEnd(code);
    }
    if (markdownLineEnding(code)) {
      return effects.check(continuationConstruct, contentContinue, contentEnd)(code);
    }
    effects.consume(code);
    return chunkInside;
  }
  function contentEnd(code) {
    effects.exit("chunkContent");
    effects.exit("content");
    return ok(code);
  }
  function contentContinue(code) {
    effects.consume(code);
    effects.exit("chunkContent");
    previous2.next = effects.enter("chunkContent", {
      contentType: "content",
      previous: previous2
    });
    previous2 = previous2.next;
    return chunkInside;
  }
}
function tokenizeContinuation(effects, ok, nok) {
  const self = this;
  return startLookahead;
  function startLookahead(code) {
    effects.exit("chunkContent");
    effects.enter("lineEnding");
    effects.consume(code);
    effects.exit("lineEnding");
    return factorySpace(effects, prefixed, "linePrefix");
  }
  function prefixed(code) {
    if (code === null || markdownLineEnding(code)) {
      return nok(code);
    }
    const tail = self.events[self.events.length - 1];
    if (!self.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
      return ok(code);
    }
    return effects.interrupt(self.parser.constructs.flow, nok, ok)(code);
  }
}

// node_modules/micromark-factory-destination/index.js
function factoryDestination(effects, ok, nok, type, literalType, literalMarkerType, rawType, stringType, max) {
  const limit = max || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start;
  function start(code) {
    if (code === 60) {
      effects.enter(type);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code);
      effects.exit(literalMarkerType);
      return enclosedBefore;
    }
    if (code === null || code === 32 || code === 41 || asciiControl(code)) {
      return nok(code);
    }
    effects.enter(type);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return raw(code);
  }
  function enclosedBefore(code) {
    if (code === 62) {
      effects.enter(literalMarkerType);
      effects.consume(code);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type);
      return ok;
    }
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return enclosed(code);
  }
  function enclosed(code) {
    if (code === 62) {
      effects.exit("chunkString");
      effects.exit(stringType);
      return enclosedBefore(code);
    }
    if (code === null || code === 60 || markdownLineEnding(code)) {
      return nok(code);
    }
    effects.consume(code);
    return code === 92 ? enclosedEscape : enclosed;
  }
  function enclosedEscape(code) {
    if (code === 60 || code === 62 || code === 92) {
      effects.consume(code);
      return enclosed;
    }
    return enclosed(code);
  }
  function raw(code) {
    if (!balance && (code === null || code === 41 || markdownLineEndingOrSpace(code))) {
      effects.exit("chunkString");
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type);
      return ok(code);
    }
    if (balance < limit && code === 40) {
      effects.consume(code);
      balance++;
      return raw;
    }
    if (code === 41) {
      effects.consume(code);
      balance--;
      return raw;
    }
    if (code === null || code === 32 || code === 40 || asciiControl(code)) {
      return nok(code);
    }
    effects.consume(code);
    return code === 92 ? rawEscape : raw;
  }
  function rawEscape(code) {
    if (code === 40 || code === 41 || code === 92) {
      effects.consume(code);
      return raw;
    }
    return raw(code);
  }
}

// node_modules/micromark-factory-label/index.js
function factoryLabel(effects, ok, nok, type, markerType, stringType) {
  const self = this;
  let size = 0;
  let seen;
  return start;
  function start(code) {
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code) {
    if (size > 999 || code === null || code === 91 || code === 93 && !seen || code === 94 && !size && "_hiddenFootnoteSupport" in self.parser.constructs) {
      return nok(code);
    }
    if (code === 93) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code);
      effects.exit(markerType);
      effects.exit(type);
      return ok;
    }
    if (markdownLineEnding(code)) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return atBreak;
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return labelInside(code);
  }
  function labelInside(code) {
    if (code === null || code === 91 || code === 93 || markdownLineEnding(code) || size++ > 999) {
      effects.exit("chunkString");
      return atBreak(code);
    }
    effects.consume(code);
    if (!seen)
      seen = !markdownSpace(code);
    return code === 92 ? labelEscape : labelInside;
  }
  function labelEscape(code) {
    if (code === 91 || code === 92 || code === 93) {
      effects.consume(code);
      size++;
      return labelInside;
    }
    return labelInside(code);
  }
}

// node_modules/micromark-factory-title/index.js
function factoryTitle(effects, ok, nok, type, markerType, stringType) {
  let marker;
  return start;
  function start(code) {
    if (code === 34 || code === 39 || code === 40) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code);
      effects.exit(markerType);
      marker = code === 40 ? 41 : code;
      return begin;
    }
    return nok(code);
  }
  function begin(code) {
    if (code === marker) {
      effects.enter(markerType);
      effects.consume(code);
      effects.exit(markerType);
      effects.exit(type);
      return ok;
    }
    effects.enter(stringType);
    return atBreak(code);
  }
  function atBreak(code) {
    if (code === marker) {
      effects.exit(stringType);
      return begin(marker);
    }
    if (code === null) {
      return nok(code);
    }
    if (markdownLineEnding(code)) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return factorySpace(effects, atBreak, "linePrefix");
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return inside(code);
  }
  function inside(code) {
    if (code === marker || code === null || markdownLineEnding(code)) {
      effects.exit("chunkString");
      return atBreak(code);
    }
    effects.consume(code);
    return code === 92 ? escape : inside;
  }
  function escape(code) {
    if (code === marker || code === 92) {
      effects.consume(code);
      return inside;
    }
    return inside(code);
  }
}

// node_modules/micromark-factory-whitespace/index.js
function factoryWhitespace(effects, ok) {
  let seen;
  return start;
  function start(code) {
    if (markdownLineEnding(code)) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      seen = true;
      return start;
    }
    if (markdownSpace(code)) {
      return factorySpace(effects, start, seen ? "linePrefix" : "lineSuffix")(code);
    }
    return ok(code);
  }
}

// node_modules/micromark-core-commonmark/lib/definition.js
var definition = {
  name: "definition",
  tokenize: tokenizeDefinition
};
var titleBefore = {
  tokenize: tokenizeTitleBefore,
  partial: true
};
function tokenizeDefinition(effects, ok, nok) {
  const self = this;
  let identifier;
  return start;
  function start(code) {
    effects.enter("definition");
    return before(code);
  }
  function before(code) {
    return factoryLabel.call(self, effects, labelAfter, nok, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(code);
  }
  function labelAfter(code) {
    identifier = normalizeIdentifier(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1));
    if (code === 58) {
      effects.enter("definitionMarker");
      effects.consume(code);
      effects.exit("definitionMarker");
      return markerAfter;
    }
    return nok(code);
  }
  function markerAfter(code) {
    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, destinationBefore)(code) : destinationBefore(code);
  }
  function destinationBefore(code) {
    return factoryDestination(effects, destinationAfter, nok, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString")(code);
  }
  function destinationAfter(code) {
    return effects.attempt(titleBefore, after, after)(code);
  }
  function after(code) {
    return markdownSpace(code) ? factorySpace(effects, afterWhitespace, "whitespace")(code) : afterWhitespace(code);
  }
  function afterWhitespace(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit("definition");
      self.parser.defined.push(identifier);
      return ok(code);
    }
    return nok(code);
  }
}
function tokenizeTitleBefore(effects, ok, nok) {
  return titleBefore2;
  function titleBefore2(code) {
    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, beforeMarker)(code) : nok(code);
  }
  function beforeMarker(code) {
    return factoryTitle(effects, titleAfter, nok, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(code);
  }
  function titleAfter(code) {
    return markdownSpace(code) ? factorySpace(effects, titleAfterOptionalWhitespace, "whitespace")(code) : titleAfterOptionalWhitespace(code);
  }
  function titleAfterOptionalWhitespace(code) {
    return code === null || markdownLineEnding(code) ? ok(code) : nok(code);
  }
}

// node_modules/micromark-core-commonmark/lib/hard-break-escape.js
var hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok, nok) {
  return start;
  function start(code) {
    effects.enter("hardBreakEscape");
    effects.consume(code);
    return after;
  }
  function after(code) {
    if (markdownLineEnding(code)) {
      effects.exit("hardBreakEscape");
      return ok(code);
    }
    return nok(code);
  }
}

// node_modules/micromark-core-commonmark/lib/heading-atx.js
var headingAtx = {
  name: "headingAtx",
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content3;
  let text3;
  if (events[contentStart][1].type === "whitespace") {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content3 = {
      type: "atxHeadingText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text3 = {
      type: "chunkText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: "text"
    };
    splice(events, contentStart, contentEnd - contentStart + 1, [
      ["enter", content3, context],
      ["enter", text3, context],
      ["exit", text3, context],
      ["exit", content3, context]
    ]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok, nok) {
  let size = 0;
  return start;
  function start(code) {
    effects.enter("atxHeading");
    return before(code);
  }
  function before(code) {
    effects.enter("atxHeadingSequence");
    return sequenceOpen(code);
  }
  function sequenceOpen(code) {
    if (code === 35 && size++ < 6) {
      effects.consume(code);
      return sequenceOpen;
    }
    if (code === null || markdownLineEndingOrSpace(code)) {
      effects.exit("atxHeadingSequence");
      return atBreak(code);
    }
    return nok(code);
  }
  function atBreak(code) {
    if (code === 35) {
      effects.enter("atxHeadingSequence");
      return sequenceFurther(code);
    }
    if (code === null || markdownLineEnding(code)) {
      effects.exit("atxHeading");
      return ok(code);
    }
    if (markdownSpace(code)) {
      return factorySpace(effects, atBreak, "whitespace")(code);
    }
    effects.enter("atxHeadingText");
    return data(code);
  }
  function sequenceFurther(code) {
    if (code === 35) {
      effects.consume(code);
      return sequenceFurther;
    }
    effects.exit("atxHeadingSequence");
    return atBreak(code);
  }
  function data(code) {
    if (code === null || code === 35 || markdownLineEndingOrSpace(code)) {
      effects.exit("atxHeadingText");
      return atBreak(code);
    }
    effects.consume(code);
    return data;
  }
}

// node_modules/micromark-util-html-tag-name/index.js
var htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var htmlRawNames = ["pre", "script", "style", "textarea"];

// node_modules/micromark-core-commonmark/lib/html-flow.js
var htmlFlow = {
  name: "htmlFlow",
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: true
};
var blankLineBefore = {
  tokenize: tokenizeBlankLineBefore,
  partial: true
};
var nonLazyContinuationStart = {
  tokenize: tokenizeNonLazyContinuationStart,
  partial: true
};
function resolveToHtmlFlow(events) {
  let index2 = events.length;
  while (index2--) {
    if (events[index2][0] === "enter" && events[index2][1].type === "htmlFlow") {
      break;
    }
  }
  if (index2 > 1 && events[index2 - 2][1].type === "linePrefix") {
    events[index2][1].start = events[index2 - 2][1].start;
    events[index2 + 1][1].start = events[index2 - 2][1].start;
    events.splice(index2 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok, nok) {
  const self = this;
  let marker;
  let closingTag;
  let buffer;
  let index2;
  let markerB;
  return start;
  function start(code) {
    return before(code);
  }
  function before(code) {
    effects.enter("htmlFlow");
    effects.enter("htmlFlowData");
    effects.consume(code);
    return open;
  }
  function open(code) {
    if (code === 33) {
      effects.consume(code);
      return declarationOpen;
    }
    if (code === 47) {
      effects.consume(code);
      closingTag = true;
      return tagCloseStart;
    }
    if (code === 63) {
      effects.consume(code);
      marker = 3;
      return self.interrupt ? ok : continuationDeclarationInside;
    }
    if (asciiAlpha(code)) {
      effects.consume(code);
      buffer = String.fromCharCode(code);
      return tagName;
    }
    return nok(code);
  }
  function declarationOpen(code) {
    if (code === 45) {
      effects.consume(code);
      marker = 2;
      return commentOpenInside;
    }
    if (code === 91) {
      effects.consume(code);
      marker = 5;
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code)) {
      effects.consume(code);
      marker = 4;
      return self.interrupt ? ok : continuationDeclarationInside;
    }
    return nok(code);
  }
  function commentOpenInside(code) {
    if (code === 45) {
      effects.consume(code);
      return self.interrupt ? ok : continuationDeclarationInside;
    }
    return nok(code);
  }
  function cdataOpenInside(code) {
    const value = "CDATA[";
    if (code === value.charCodeAt(index2++)) {
      effects.consume(code);
      if (index2 === value.length) {
        return self.interrupt ? ok : continuation;
      }
      return cdataOpenInside;
    }
    return nok(code);
  }
  function tagCloseStart(code) {
    if (asciiAlpha(code)) {
      effects.consume(code);
      buffer = String.fromCharCode(code);
      return tagName;
    }
    return nok(code);
  }
  function tagName(code) {
    if (code === null || code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {
      const slash = code === 47;
      const name = buffer.toLowerCase();
      if (!slash && !closingTag && htmlRawNames.includes(name)) {
        marker = 1;
        return self.interrupt ? ok(code) : continuation(code);
      }
      if (htmlBlockNames.includes(buffer.toLowerCase())) {
        marker = 6;
        if (slash) {
          effects.consume(code);
          return basicSelfClosing;
        }
        return self.interrupt ? ok(code) : continuation(code);
      }
      marker = 7;
      return self.interrupt && !self.parser.lazy[self.now().line] ? nok(code) : closingTag ? completeClosingTagAfter(code) : completeAttributeNameBefore(code);
    }
    if (code === 45 || asciiAlphanumeric(code)) {
      effects.consume(code);
      buffer += String.fromCharCode(code);
      return tagName;
    }
    return nok(code);
  }
  function basicSelfClosing(code) {
    if (code === 62) {
      effects.consume(code);
      return self.interrupt ? ok : continuation;
    }
    return nok(code);
  }
  function completeClosingTagAfter(code) {
    if (markdownSpace(code)) {
      effects.consume(code);
      return completeClosingTagAfter;
    }
    return completeEnd(code);
  }
  function completeAttributeNameBefore(code) {
    if (code === 47) {
      effects.consume(code);
      return completeEnd;
    }
    if (code === 58 || code === 95 || asciiAlpha(code)) {
      effects.consume(code);
      return completeAttributeName;
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return completeAttributeNameBefore;
    }
    return completeEnd(code);
  }
  function completeAttributeName(code) {
    if (code === 45 || code === 46 || code === 58 || code === 95 || asciiAlphanumeric(code)) {
      effects.consume(code);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code);
  }
  function completeAttributeNameAfter(code) {
    if (code === 61) {
      effects.consume(code);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code);
  }
  function completeAttributeValueBefore(code) {
    if (code === null || code === 60 || code === 61 || code === 62 || code === 96) {
      return nok(code);
    }
    if (code === 34 || code === 39) {
      effects.consume(code);
      markerB = code;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return completeAttributeValueBefore;
    }
    return completeAttributeValueUnquoted(code);
  }
  function completeAttributeValueQuoted(code) {
    if (code === markerB) {
      effects.consume(code);
      markerB = null;
      return completeAttributeValueQuotedAfter;
    }
    if (code === null || markdownLineEnding(code)) {
      return nok(code);
    }
    effects.consume(code);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code) {
    if (code === null || code === 34 || code === 39 || code === 47 || code === 60 || code === 61 || code === 62 || code === 96 || markdownLineEndingOrSpace(code)) {
      return completeAttributeNameAfter(code);
    }
    effects.consume(code);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code) {
    if (code === 47 || code === 62 || markdownSpace(code)) {
      return completeAttributeNameBefore(code);
    }
    return nok(code);
  }
  function completeEnd(code) {
    if (code === 62) {
      effects.consume(code);
      return completeAfter;
    }
    return nok(code);
  }
  function completeAfter(code) {
    if (code === null || markdownLineEnding(code)) {
      return continuation(code);
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return completeAfter;
    }
    return nok(code);
  }
  function continuation(code) {
    if (code === 45 && marker === 2) {
      effects.consume(code);
      return continuationCommentInside;
    }
    if (code === 60 && marker === 1) {
      effects.consume(code);
      return continuationRawTagOpen;
    }
    if (code === 62 && marker === 4) {
      effects.consume(code);
      return continuationClose;
    }
    if (code === 63 && marker === 3) {
      effects.consume(code);
      return continuationDeclarationInside;
    }
    if (code === 93 && marker === 5) {
      effects.consume(code);
      return continuationCdataInside;
    }
    if (markdownLineEnding(code) && (marker === 6 || marker === 7)) {
      effects.exit("htmlFlowData");
      return effects.check(blankLineBefore, continuationAfter, continuationStart)(code);
    }
    if (code === null || markdownLineEnding(code)) {
      effects.exit("htmlFlowData");
      return continuationStart(code);
    }
    effects.consume(code);
    return continuation;
  }
  function continuationStart(code) {
    return effects.check(nonLazyContinuationStart, continuationStartNonLazy, continuationAfter)(code);
  }
  function continuationStartNonLazy(code) {
    effects.enter("lineEnding");
    effects.consume(code);
    effects.exit("lineEnding");
    return continuationBefore;
  }
  function continuationBefore(code) {
    if (code === null || markdownLineEnding(code)) {
      return continuationStart(code);
    }
    effects.enter("htmlFlowData");
    return continuation(code);
  }
  function continuationCommentInside(code) {
    if (code === 45) {
      effects.consume(code);
      return continuationDeclarationInside;
    }
    return continuation(code);
  }
  function continuationRawTagOpen(code) {
    if (code === 47) {
      effects.consume(code);
      buffer = "";
      return continuationRawEndTag;
    }
    return continuation(code);
  }
  function continuationRawEndTag(code) {
    if (code === 62) {
      const name = buffer.toLowerCase();
      if (htmlRawNames.includes(name)) {
        effects.consume(code);
        return continuationClose;
      }
      return continuation(code);
    }
    if (asciiAlpha(code) && buffer.length < 8) {
      effects.consume(code);
      buffer += String.fromCharCode(code);
      return continuationRawEndTag;
    }
    return continuation(code);
  }
  function continuationCdataInside(code) {
    if (code === 93) {
      effects.consume(code);
      return continuationDeclarationInside;
    }
    return continuation(code);
  }
  function continuationDeclarationInside(code) {
    if (code === 62) {
      effects.consume(code);
      return continuationClose;
    }
    if (code === 45 && marker === 2) {
      effects.consume(code);
      return continuationDeclarationInside;
    }
    return continuation(code);
  }
  function continuationClose(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit("htmlFlowData");
      return continuationAfter(code);
    }
    effects.consume(code);
    return continuationClose;
  }
  function continuationAfter(code) {
    effects.exit("htmlFlow");
    return ok(code);
  }
}
function tokenizeNonLazyContinuationStart(effects, ok, nok) {
  const self = this;
  return start;
  function start(code) {
    if (markdownLineEnding(code)) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return after;
    }
    return nok(code);
  }
  function after(code) {
    return self.parser.lazy[self.now().line] ? nok(code) : ok(code);
  }
}
function tokenizeBlankLineBefore(effects, ok, nok) {
  return start;
  function start(code) {
    effects.enter("lineEnding");
    effects.consume(code);
    effects.exit("lineEnding");
    return effects.attempt(blankLine, ok, nok);
  }
}

// node_modules/micromark-core-commonmark/lib/html-text.js
var htmlText = {
  name: "htmlText",
  tokenize: tokenizeHtmlText
};
function tokenizeHtmlText(effects, ok, nok) {
  const self = this;
  let marker;
  let index2;
  let returnState;
  return start;
  function start(code) {
    effects.enter("htmlText");
    effects.enter("htmlTextData");
    effects.consume(code);
    return open;
  }
  function open(code) {
    if (code === 33) {
      effects.consume(code);
      return declarationOpen;
    }
    if (code === 47) {
      effects.consume(code);
      return tagCloseStart;
    }
    if (code === 63) {
      effects.consume(code);
      return instruction;
    }
    if (asciiAlpha(code)) {
      effects.consume(code);
      return tagOpen;
    }
    return nok(code);
  }
  function declarationOpen(code) {
    if (code === 45) {
      effects.consume(code);
      return commentOpenInside;
    }
    if (code === 91) {
      effects.consume(code);
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code)) {
      effects.consume(code);
      return declaration;
    }
    return nok(code);
  }
  function commentOpenInside(code) {
    if (code === 45) {
      effects.consume(code);
      return commentEnd;
    }
    return nok(code);
  }
  function comment(code) {
    if (code === null) {
      return nok(code);
    }
    if (code === 45) {
      effects.consume(code);
      return commentClose;
    }
    if (markdownLineEnding(code)) {
      returnState = comment;
      return lineEndingBefore(code);
    }
    effects.consume(code);
    return comment;
  }
  function commentClose(code) {
    if (code === 45) {
      effects.consume(code);
      return commentEnd;
    }
    return comment(code);
  }
  function commentEnd(code) {
    return code === 62 ? end(code) : code === 45 ? commentClose(code) : comment(code);
  }
  function cdataOpenInside(code) {
    const value = "CDATA[";
    if (code === value.charCodeAt(index2++)) {
      effects.consume(code);
      return index2 === value.length ? cdata : cdataOpenInside;
    }
    return nok(code);
  }
  function cdata(code) {
    if (code === null) {
      return nok(code);
    }
    if (code === 93) {
      effects.consume(code);
      return cdataClose;
    }
    if (markdownLineEnding(code)) {
      returnState = cdata;
      return lineEndingBefore(code);
    }
    effects.consume(code);
    return cdata;
  }
  function cdataClose(code) {
    if (code === 93) {
      effects.consume(code);
      return cdataEnd;
    }
    return cdata(code);
  }
  function cdataEnd(code) {
    if (code === 62) {
      return end(code);
    }
    if (code === 93) {
      effects.consume(code);
      return cdataEnd;
    }
    return cdata(code);
  }
  function declaration(code) {
    if (code === null || code === 62) {
      return end(code);
    }
    if (markdownLineEnding(code)) {
      returnState = declaration;
      return lineEndingBefore(code);
    }
    effects.consume(code);
    return declaration;
  }
  function instruction(code) {
    if (code === null) {
      return nok(code);
    }
    if (code === 63) {
      effects.consume(code);
      return instructionClose;
    }
    if (markdownLineEnding(code)) {
      returnState = instruction;
      return lineEndingBefore(code);
    }
    effects.consume(code);
    return instruction;
  }
  function instructionClose(code) {
    return code === 62 ? end(code) : instruction(code);
  }
  function tagCloseStart(code) {
    if (asciiAlpha(code)) {
      effects.consume(code);
      return tagClose;
    }
    return nok(code);
  }
  function tagClose(code) {
    if (code === 45 || asciiAlphanumeric(code)) {
      effects.consume(code);
      return tagClose;
    }
    return tagCloseBetween(code);
  }
  function tagCloseBetween(code) {
    if (markdownLineEnding(code)) {
      returnState = tagCloseBetween;
      return lineEndingBefore(code);
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return tagCloseBetween;
    }
    return end(code);
  }
  function tagOpen(code) {
    if (code === 45 || asciiAlphanumeric(code)) {
      effects.consume(code);
      return tagOpen;
    }
    if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {
      return tagOpenBetween(code);
    }
    return nok(code);
  }
  function tagOpenBetween(code) {
    if (code === 47) {
      effects.consume(code);
      return end;
    }
    if (code === 58 || code === 95 || asciiAlpha(code)) {
      effects.consume(code);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code)) {
      returnState = tagOpenBetween;
      return lineEndingBefore(code);
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return tagOpenBetween;
    }
    return end(code);
  }
  function tagOpenAttributeName(code) {
    if (code === 45 || code === 46 || code === 58 || code === 95 || asciiAlphanumeric(code)) {
      effects.consume(code);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code);
  }
  function tagOpenAttributeNameAfter(code) {
    if (code === 61) {
      effects.consume(code);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code)) {
      returnState = tagOpenAttributeNameAfter;
      return lineEndingBefore(code);
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code);
  }
  function tagOpenAttributeValueBefore(code) {
    if (code === null || code === 60 || code === 61 || code === 62 || code === 96) {
      return nok(code);
    }
    if (code === 34 || code === 39) {
      effects.consume(code);
      marker = code;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code)) {
      returnState = tagOpenAttributeValueBefore;
      return lineEndingBefore(code);
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code) {
    if (code === marker) {
      effects.consume(code);
      marker = void 0;
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code === null) {
      return nok(code);
    }
    if (markdownLineEnding(code)) {
      returnState = tagOpenAttributeValueQuoted;
      return lineEndingBefore(code);
    }
    effects.consume(code);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueUnquoted(code) {
    if (code === null || code === 34 || code === 39 || code === 60 || code === 61 || code === 96) {
      return nok(code);
    }
    if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {
      return tagOpenBetween(code);
    }
    effects.consume(code);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuotedAfter(code) {
    if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {
      return tagOpenBetween(code);
    }
    return nok(code);
  }
  function end(code) {
    if (code === 62) {
      effects.consume(code);
      effects.exit("htmlTextData");
      effects.exit("htmlText");
      return ok;
    }
    return nok(code);
  }
  function lineEndingBefore(code) {
    effects.exit("htmlTextData");
    effects.enter("lineEnding");
    effects.consume(code);
    effects.exit("lineEnding");
    return lineEndingAfter;
  }
  function lineEndingAfter(code) {
    return markdownSpace(code) ? factorySpace(effects, lineEndingAfterPrefix, "linePrefix", self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code) : lineEndingAfterPrefix(code);
  }
  function lineEndingAfterPrefix(code) {
    effects.enter("htmlTextData");
    return returnState(code);
  }
}

// node_modules/micromark-core-commonmark/lib/label-end.js
var labelEnd = {
  name: "labelEnd",
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
};
var resourceConstruct = {
  tokenize: tokenizeResource
};
var referenceFullConstruct = {
  tokenize: tokenizeReferenceFull
};
var referenceCollapsedConstruct = {
  tokenize: tokenizeReferenceCollapsed
};
function resolveAllLabelEnd(events) {
  let index2 = -1;
  while (++index2 < events.length) {
    const token = events[index2][1];
    if (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {
      events.splice(index2 + 1, token.type === "labelImage" ? 4 : 2);
      token.type = "data";
      index2++;
    }
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index2 = events.length;
  let offset = 0;
  let token;
  let open;
  let close;
  let media;
  while (index2--) {
    token = events[index2][1];
    if (open) {
      if (token.type === "link" || token.type === "labelLink" && token._inactive) {
        break;
      }
      if (events[index2][0] === "enter" && token.type === "labelLink") {
        token._inactive = true;
      }
    } else if (close) {
      if (events[index2][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
        open = index2;
        if (token.type !== "labelLink") {
          offset = 2;
          break;
        }
      }
    } else if (token.type === "labelEnd") {
      close = index2;
    }
  }
  const group = {
    type: events[open][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const label = {
    type: "label",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[close][1].end)
  };
  const text3 = {
    type: "labelText",
    start: Object.assign({}, events[open + offset + 2][1].end),
    end: Object.assign({}, events[close - 2][1].start)
  };
  media = [
    ["enter", group, context],
    ["enter", label, context]
  ];
  media = push(media, events.slice(open + 1, open + offset + 3));
  media = push(media, [["enter", text3, context]]);
  media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close - 3), context));
  media = push(media, [
    ["exit", text3, context],
    events[close - 2],
    events[close - 1],
    ["exit", label, context]
  ]);
  media = push(media, events.slice(close + 1));
  media = push(media, [["exit", group, context]]);
  splice(events, open, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok, nok) {
  const self = this;
  let index2 = self.events.length;
  let labelStart;
  let defined;
  while (index2--) {
    if ((self.events[index2][1].type === "labelImage" || self.events[index2][1].type === "labelLink") && !self.events[index2][1]._balanced) {
      labelStart = self.events[index2][1];
      break;
    }
  }
  return start;
  function start(code) {
    if (!labelStart) {
      return nok(code);
    }
    if (labelStart._inactive) {
      return labelEndNok(code);
    }
    defined = self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize({
      start: labelStart.end,
      end: self.now()
    })));
    effects.enter("labelEnd");
    effects.enter("labelMarker");
    effects.consume(code);
    effects.exit("labelMarker");
    effects.exit("labelEnd");
    return after;
  }
  function after(code) {
    if (code === 40) {
      return effects.attempt(resourceConstruct, labelEndOk, defined ? labelEndOk : labelEndNok)(code);
    }
    if (code === 91) {
      return effects.attempt(referenceFullConstruct, labelEndOk, defined ? referenceNotFull : labelEndNok)(code);
    }
    return defined ? labelEndOk(code) : labelEndNok(code);
  }
  function referenceNotFull(code) {
    return effects.attempt(referenceCollapsedConstruct, labelEndOk, labelEndNok)(code);
  }
  function labelEndOk(code) {
    return ok(code);
  }
  function labelEndNok(code) {
    labelStart._balanced = true;
    return nok(code);
  }
}
function tokenizeResource(effects, ok, nok) {
  return resourceStart;
  function resourceStart(code) {
    effects.enter("resource");
    effects.enter("resourceMarker");
    effects.consume(code);
    effects.exit("resourceMarker");
    return resourceBefore;
  }
  function resourceBefore(code) {
    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceOpen)(code) : resourceOpen(code);
  }
  function resourceOpen(code) {
    if (code === 41) {
      return resourceEnd(code);
    }
    return factoryDestination(effects, resourceDestinationAfter, resourceDestinationMissing, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(code);
  }
  function resourceDestinationAfter(code) {
    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceBetween)(code) : resourceEnd(code);
  }
  function resourceDestinationMissing(code) {
    return nok(code);
  }
  function resourceBetween(code) {
    if (code === 34 || code === 39 || code === 40) {
      return factoryTitle(effects, resourceTitleAfter, nok, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(code);
    }
    return resourceEnd(code);
  }
  function resourceTitleAfter(code) {
    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceEnd)(code) : resourceEnd(code);
  }
  function resourceEnd(code) {
    if (code === 41) {
      effects.enter("resourceMarker");
      effects.consume(code);
      effects.exit("resourceMarker");
      effects.exit("resource");
      return ok;
    }
    return nok(code);
  }
}
function tokenizeReferenceFull(effects, ok, nok) {
  const self = this;
  return referenceFull;
  function referenceFull(code) {
    return factoryLabel.call(self, effects, referenceFullAfter, referenceFullMissing, "reference", "referenceMarker", "referenceString")(code);
  }
  function referenceFullAfter(code) {
    return self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1))) ? ok(code) : nok(code);
  }
  function referenceFullMissing(code) {
    return nok(code);
  }
}
function tokenizeReferenceCollapsed(effects, ok, nok) {
  return referenceCollapsedStart;
  function referenceCollapsedStart(code) {
    effects.enter("reference");
    effects.enter("referenceMarker");
    effects.consume(code);
    effects.exit("referenceMarker");
    return referenceCollapsedOpen;
  }
  function referenceCollapsedOpen(code) {
    if (code === 93) {
      effects.enter("referenceMarker");
      effects.consume(code);
      effects.exit("referenceMarker");
      effects.exit("reference");
      return ok;
    }
    return nok(code);
  }
}

// node_modules/micromark-core-commonmark/lib/label-start-image.js
var labelStartImage = {
  name: "labelStartImage",
  tokenize: tokenizeLabelStartImage,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartImage(effects, ok, nok) {
  const self = this;
  return start;
  function start(code) {
    effects.enter("labelImage");
    effects.enter("labelImageMarker");
    effects.consume(code);
    effects.exit("labelImageMarker");
    return open;
  }
  function open(code) {
    if (code === 91) {
      effects.enter("labelMarker");
      effects.consume(code);
      effects.exit("labelMarker");
      effects.exit("labelImage");
      return after;
    }
    return nok(code);
  }
  function after(code) {
    return code === 94 && "_hiddenFootnoteSupport" in self.parser.constructs ? nok(code) : ok(code);
  }
}

// node_modules/micromark-core-commonmark/lib/label-start-link.js
var labelStartLink = {
  name: "labelStartLink",
  tokenize: tokenizeLabelStartLink,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartLink(effects, ok, nok) {
  const self = this;
  return start;
  function start(code) {
    effects.enter("labelLink");
    effects.enter("labelMarker");
    effects.consume(code);
    effects.exit("labelMarker");
    effects.exit("labelLink");
    return after;
  }
  function after(code) {
    return code === 94 && "_hiddenFootnoteSupport" in self.parser.constructs ? nok(code) : ok(code);
  }
}

// node_modules/micromark-core-commonmark/lib/line-ending.js
var lineEnding = {
  name: "lineEnding",
  tokenize: tokenizeLineEnding
};
function tokenizeLineEnding(effects, ok) {
  return start;
  function start(code) {
    effects.enter("lineEnding");
    effects.consume(code);
    effects.exit("lineEnding");
    return factorySpace(effects, ok, "linePrefix");
  }
}

// node_modules/micromark-core-commonmark/lib/thematic-break.js
var thematicBreak = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok, nok) {
  let size = 0;
  let marker;
  return start;
  function start(code) {
    effects.enter("thematicBreak");
    return before(code);
  }
  function before(code) {
    marker = code;
    return atBreak(code);
  }
  function atBreak(code) {
    if (code === marker) {
      effects.enter("thematicBreakSequence");
      return sequence(code);
    }
    if (size >= 3 && (code === null || markdownLineEnding(code))) {
      effects.exit("thematicBreak");
      return ok(code);
    }
    return nok(code);
  }
  function sequence(code) {
    if (code === marker) {
      effects.consume(code);
      size++;
      return sequence;
    }
    effects.exit("thematicBreakSequence");
    return markdownSpace(code) ? factorySpace(effects, atBreak, "whitespace")(code) : atBreak(code);
  }
}

// node_modules/micromark-core-commonmark/lib/list.js
var list = {
  name: "list",
  tokenize: tokenizeListStart,
  continuation: {
    tokenize: tokenizeListContinuation
  },
  exit: tokenizeListEnd
};
var listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: true
};
var indentConstruct = {
  tokenize: tokenizeIndent,
  partial: true
};
function tokenizeListStart(effects, ok, nok) {
  const self = this;
  const tail = self.events[self.events.length - 1];
  let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size = 0;
  return start;
  function start(code) {
    const kind = self.containerState.type || (code === 42 || code === 43 || code === 45 ? "listUnordered" : "listOrdered");
    if (kind === "listUnordered" ? !self.containerState.marker || code === self.containerState.marker : asciiDigit(code)) {
      if (!self.containerState.type) {
        self.containerState.type = kind;
        effects.enter(kind, {
          _container: true
        });
      }
      if (kind === "listUnordered") {
        effects.enter("listItemPrefix");
        return code === 42 || code === 45 ? effects.check(thematicBreak, nok, atMarker)(code) : atMarker(code);
      }
      if (!self.interrupt || code === 49) {
        effects.enter("listItemPrefix");
        effects.enter("listItemValue");
        return inside(code);
      }
    }
    return nok(code);
  }
  function inside(code) {
    if (asciiDigit(code) && ++size < 10) {
      effects.consume(code);
      return inside;
    }
    if ((!self.interrupt || size < 2) && (self.containerState.marker ? code === self.containerState.marker : code === 41 || code === 46)) {
      effects.exit("listItemValue");
      return atMarker(code);
    }
    return nok(code);
  }
  function atMarker(code) {
    effects.enter("listItemMarker");
    effects.consume(code);
    effects.exit("listItemMarker");
    self.containerState.marker = self.containerState.marker || code;
    return effects.check(blankLine, self.interrupt ? nok : onBlank, effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix));
  }
  function onBlank(code) {
    self.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code);
  }
  function otherPrefix(code) {
    if (markdownSpace(code)) {
      effects.enter("listItemPrefixWhitespace");
      effects.consume(code);
      effects.exit("listItemPrefixWhitespace");
      return endOfPrefix;
    }
    return nok(code);
  }
  function endOfPrefix(code) {
    self.containerState.size = initialSize + self.sliceSerialize(effects.exit("listItemPrefix"), true).length;
    return ok(code);
  }
}
function tokenizeListContinuation(effects, ok, nok) {
  const self = this;
  self.containerState._closeFlow = void 0;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code) {
    self.containerState.furtherBlankLines = self.containerState.furtherBlankLines || self.containerState.initialBlankLine;
    return factorySpace(effects, ok, "listItemIndent", self.containerState.size + 1)(code);
  }
  function notBlank(code) {
    if (self.containerState.furtherBlankLines || !markdownSpace(code)) {
      self.containerState.furtherBlankLines = void 0;
      self.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code);
    }
    self.containerState.furtherBlankLines = void 0;
    self.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code);
  }
  function notInCurrentItem(code) {
    self.containerState._closeFlow = true;
    self.interrupt = void 0;
    return factorySpace(effects, effects.attempt(list, ok, nok), "linePrefix", self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code);
  }
}
function tokenizeIndent(effects, ok, nok) {
  const self = this;
  return factorySpace(effects, afterPrefix, "listItemIndent", self.containerState.size + 1);
  function afterPrefix(code) {
    const tail = self.events[self.events.length - 1];
    return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self.containerState.size ? ok(code) : nok(code);
  }
}
function tokenizeListEnd(effects) {
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok, nok) {
  const self = this;
  return factorySpace(effects, afterPrefix, "listItemPrefixWhitespace", self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1);
  function afterPrefix(code) {
    const tail = self.events[self.events.length - 1];
    return !markdownSpace(code) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok(code) : nok(code);
  }
}

// node_modules/micromark-core-commonmark/lib/setext-underline.js
var setextUnderline = {
  name: "setextUnderline",
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index2 = events.length;
  let content3;
  let text3;
  let definition2;
  while (index2--) {
    if (events[index2][0] === "enter") {
      if (events[index2][1].type === "content") {
        content3 = index2;
        break;
      }
      if (events[index2][1].type === "paragraph") {
        text3 = index2;
      }
    } else {
      if (events[index2][1].type === "content") {
        events.splice(index2, 1);
      }
      if (!definition2 && events[index2][1].type === "definition") {
        definition2 = index2;
      }
    }
  }
  const heading = {
    type: "setextHeading",
    start: Object.assign({}, events[text3][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  events[text3][1].type = "setextHeadingText";
  if (definition2) {
    events.splice(text3, 0, ["enter", heading, context]);
    events.splice(definition2 + 1, 0, ["exit", events[content3][1], context]);
    events[content3][1].end = Object.assign({}, events[definition2][1].end);
  } else {
    events[content3][1] = heading;
  }
  events.push(["exit", heading, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok, nok) {
  const self = this;
  let marker;
  return start;
  function start(code) {
    let index2 = self.events.length;
    let paragraph;
    while (index2--) {
      if (self.events[index2][1].type !== "lineEnding" && self.events[index2][1].type !== "linePrefix" && self.events[index2][1].type !== "content") {
        paragraph = self.events[index2][1].type === "paragraph";
        break;
      }
    }
    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {
      effects.enter("setextHeadingLine");
      marker = code;
      return before(code);
    }
    return nok(code);
  }
  function before(code) {
    effects.enter("setextHeadingLineSequence");
    return inside(code);
  }
  function inside(code) {
    if (code === marker) {
      effects.consume(code);
      return inside;
    }
    effects.exit("setextHeadingLineSequence");
    return markdownSpace(code) ? factorySpace(effects, after, "lineSuffix")(code) : after(code);
  }
  function after(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit("setextHeadingLine");
      return ok(code);
    }
    return nok(code);
  }
}

// node_modules/micromark/lib/initialize/flow.js
var flow = {
  tokenize: initializeFlow
};
function initializeFlow(effects) {
  const self = this;
  const initial = effects.attempt(blankLine, atBlankEnding, effects.attempt(this.parser.constructs.flowInitial, afterConstruct, factorySpace(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(content2, afterConstruct)), "linePrefix")));
  return initial;
  function atBlankEnding(code) {
    if (code === null) {
      effects.consume(code);
      return;
    }
    effects.enter("lineEndingBlank");
    effects.consume(code);
    effects.exit("lineEndingBlank");
    self.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code) {
    if (code === null) {
      effects.consume(code);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code);
    effects.exit("lineEnding");
    self.currentConstruct = void 0;
    return initial;
  }
}

// node_modules/micromark/lib/initialize/text.js
var resolver = {
  resolveAll: createResolver()
};
var string = initializeFactory("string");
var text = initializeFactory("text");
function initializeFactory(field) {
  return {
    tokenize: initializeText,
    resolveAll: createResolver(field === "text" ? resolveAllLineSuffixes : void 0)
  };
  function initializeText(effects) {
    const self = this;
    const constructs2 = this.parser.constructs[field];
    const text3 = effects.attempt(constructs2, start, notText);
    return start;
    function start(code) {
      return atBreak(code) ? text3(code) : notText(code);
    }
    function notText(code) {
      if (code === null) {
        effects.consume(code);
        return;
      }
      effects.enter("data");
      effects.consume(code);
      return data;
    }
    function data(code) {
      if (atBreak(code)) {
        effects.exit("data");
        return text3(code);
      }
      effects.consume(code);
      return data;
    }
    function atBreak(code) {
      if (code === null) {
        return true;
      }
      const list2 = constructs2[code];
      let index2 = -1;
      if (list2) {
        while (++index2 < list2.length) {
          const item = list2[index2];
          if (!item.previous || item.previous.call(self, self.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index2 = -1;
    let enter;
    while (++index2 <= events.length) {
      if (enter === void 0) {
        if (events[index2] && events[index2][1].type === "data") {
          enter = index2;
          index2++;
        }
      } else if (!events[index2] || events[index2][1].type !== "data") {
        if (index2 !== enter + 2) {
          events[enter][1].end = events[index2 - 1][1].end;
          events.splice(enter + 2, index2 - enter - 2);
          index2 = enter + 2;
        }
        enter = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
      const data = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data);
      let index2 = chunks.length;
      let bufferIndex = -1;
      let size = 0;
      let tabs;
      while (index2--) {
        const chunk = chunks[index2];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === 32) {
            size++;
            bufferIndex--;
          }
          if (bufferIndex)
            break;
          bufferIndex = -1;
        } else if (chunk === -2) {
          tabs = true;
          size++;
        } else if (chunk === -1) {
        } else {
          index2++;
          break;
        }
      }
      if (size) {
        const token = {
          type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: data.end.line,
            column: data.end.column - size,
            offset: data.end.offset - size,
            _index: data.start._index + index2,
            _bufferIndex: index2 ? bufferIndex : data.start._bufferIndex + bufferIndex
          },
          end: Object.assign({}, data.end)
        };
        data.end = Object.assign({}, token.start);
        if (data.start.offset === data.end.offset) {
          Object.assign(data, token);
        } else {
          events.splice(eventIndex, 0, ["enter", token, context], ["exit", token, context]);
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}

// node_modules/micromark/lib/create-tokenizer.js
function createTokenizer(parser, initialize, from) {
  let point3 = Object.assign(from ? Object.assign({}, from) : {
    line: 1,
    column: 1,
    offset: 0
  }, {
    _index: 0,
    _bufferIndex: -1
  });
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  let consumed = true;
  const effects = {
    consume,
    enter,
    exit: exit2,
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    interrupt: constructFactory(onsuccessfulcheck, {
      interrupt: true
    })
  };
  const context = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser,
    sliceStream,
    sliceSerialize,
    now,
    defineSkip,
    write
  };
  let state = initialize.tokenize.call(context, effects);
  let expectedCode;
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write(slice) {
    chunks = push(chunks, slice);
    main();
    if (chunks[chunks.length - 1] !== null) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token, expandTabs) {
    return serializeChunks(sliceStream(token), expandTabs);
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token);
  }
  function now() {
    const { line, column, offset, _index, _bufferIndex } = point3;
    return {
      line,
      column,
      offset,
      _index,
      _bufferIndex
    };
  }
  function defineSkip(value) {
    columnStart[value.line] = value.column;
    accountForPotentialSkip();
  }
  function main() {
    let chunkIndex;
    while (point3._index < chunks.length) {
      const chunk = chunks[point3._index];
      if (typeof chunk === "string") {
        chunkIndex = point3._index;
        if (point3._bufferIndex < 0) {
          point3._bufferIndex = 0;
        }
        while (point3._index === chunkIndex && point3._bufferIndex < chunk.length) {
          go(chunk.charCodeAt(point3._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }
  function go(code) {
    consumed = void 0;
    expectedCode = code;
    state = state(code);
  }
  function consume(code) {
    if (markdownLineEnding(code)) {
      point3.line++;
      point3.column = 1;
      point3.offset += code === -3 ? 2 : 1;
      accountForPotentialSkip();
    } else if (code !== -1) {
      point3.column++;
      point3.offset++;
    }
    if (point3._bufferIndex < 0) {
      point3._index++;
    } else {
      point3._bufferIndex++;
      if (point3._bufferIndex === chunks[point3._index].length) {
        point3._bufferIndex = -1;
        point3._index++;
      }
    }
    context.previous = code;
    consumed = true;
  }
  function enter(type, fields) {
    const token = fields || {};
    token.type = type;
    token.start = now();
    context.events.push(["enter", token, context]);
    stack.push(token);
    return token;
  }
  function exit2(type) {
    const token = stack.pop();
    token.end = now();
    context.events.push(["exit", token, context]);
    return token;
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  function onsuccessfulcheck(_, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? handleListOfConstructs(constructs2) : "tokenize" in constructs2 ? handleListOfConstructs([constructs2]) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map) {
        return start;
        function start(code) {
          const def = code !== null && map[code];
          const all2 = code !== null && map.null;
          const list2 = [
            ...Array.isArray(def) ? def : def ? [def] : [],
            ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
          ];
          return handleListOfConstructs(list2)(code);
        }
      }
      function handleListOfConstructs(list2) {
        listOfConstructs = list2;
        constructIndex = 0;
        if (list2.length === 0) {
          return bogusState;
        }
        return handleConstruct(list2[constructIndex]);
      }
      function handleConstruct(construct) {
        return start;
        function start(code) {
          info = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
            return nok(code);
          }
          return construct.tokenize.call(fields ? Object.assign(Object.create(context), fields) : context, effects, ok, nok)(code);
        }
      }
      function ok(code) {
        consumed = true;
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code) {
        consumed = true;
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from2) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice(context.events, from2, context.events.length - from2, construct.resolve(context.events.slice(from2), context));
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
  }
  function store() {
    const startPoint = now();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return {
      restore,
      from: startEventsIndex
    };
    function restore() {
      point3 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
    }
  }
  function accountForPotentialSkip() {
    if (point3.line in columnStart && point3.column < 2) {
      point3.column = columnStart[point3.line];
      point3.offset += columnStart[point3.line] - 1;
    }
  }
}
function sliceChunks(chunks, token) {
  const startIndex = token.start._index;
  const startBufferIndex = token.start._bufferIndex;
  const endIndex = token.end._index;
  const endBufferIndex = token.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      const head = view[0];
      if (typeof head === "string") {
        view[0] = head.slice(startBufferIndex);
      } else {
        view.shift();
      }
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index2 = -1;
  const result = [];
  let atTab;
  while (++index2 < chunks.length) {
    const chunk = chunks[index2];
    let value;
    if (typeof chunk === "string") {
      value = chunk;
    } else
      switch (chunk) {
        case -5: {
          value = "\r";
          break;
        }
        case -4: {
          value = "\n";
          break;
        }
        case -3: {
          value = "\r\n";
          break;
        }
        case -2: {
          value = expandTabs ? " " : "	";
          break;
        }
        case -1: {
          if (!expandTabs && atTab)
            continue;
          value = " ";
          break;
        }
        default: {
          value = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === -2;
    result.push(value);
  }
  return result.join("");
}

// node_modules/micromark/lib/constructs.js
var constructs_exports = {};
__export(constructs_exports, {
  attentionMarkers: () => attentionMarkers,
  contentInitial: () => contentInitial,
  disable: () => disable,
  document: () => document3,
  flow: () => flow2,
  flowInitial: () => flowInitial,
  insideSpan: () => insideSpan,
  string: () => string2,
  text: () => text2
});
var document3 = {
  [42]: list,
  [43]: list,
  [45]: list,
  [48]: list,
  [49]: list,
  [50]: list,
  [51]: list,
  [52]: list,
  [53]: list,
  [54]: list,
  [55]: list,
  [56]: list,
  [57]: list,
  [62]: blockQuote
};
var contentInitial = {
  [91]: definition
};
var flowInitial = {
  [-2]: codeIndented,
  [-1]: codeIndented,
  [32]: codeIndented
};
var flow2 = {
  [35]: headingAtx,
  [42]: thematicBreak,
  [45]: [setextUnderline, thematicBreak],
  [60]: htmlFlow,
  [61]: setextUnderline,
  [95]: thematicBreak,
  [96]: codeFenced,
  [126]: codeFenced
};
var string2 = {
  [38]: characterReference,
  [92]: characterEscape
};
var text2 = {
  [-5]: lineEnding,
  [-4]: lineEnding,
  [-3]: lineEnding,
  [33]: labelStartImage,
  [38]: characterReference,
  [42]: attention,
  [60]: [autolink, htmlText],
  [91]: labelStartLink,
  [92]: [hardBreakEscape, characterEscape],
  [93]: labelEnd,
  [95]: attention,
  [96]: codeText
};
var insideSpan = {
  null: [attention, resolver]
};
var attentionMarkers = {
  null: [42, 95]
};
var disable = {
  null: []
};

// node_modules/micromark/lib/parse.js
function parse(options) {
  const settings = options || {};
  const constructs2 = combineExtensions([constructs_exports, ...settings.extensions || []]);
  const parser = {
    defined: [],
    lazy: {},
    constructs: constructs2,
    content: create(content),
    document: create(document2),
    flow: create(flow),
    string: create(string),
    text: create(text)
  };
  return parser;
  function create(initial) {
    return creator;
    function creator(from) {
      return createTokenizer(parser, initial, from);
    }
  }
}

// node_modules/micromark/lib/postprocess.js
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}

// node_modules/micromark/lib/preprocess.js
var search = /[\0\t\n\r]/g;
function preprocess() {
  let column = 1;
  let buffer = "";
  let start = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value, encoding, end) {
    const chunks = [];
    let match;
    let next;
    let startPosition;
    let endPosition;
    let code;
    value = buffer + (typeof value === "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value));
    startPosition = 0;
    buffer = "";
    if (start) {
      if (value.charCodeAt(0) === 65279) {
        startPosition++;
      }
      start = void 0;
    }
    while (startPosition < value.length) {
      search.lastIndex = startPosition;
      match = search.exec(value);
      endPosition = match && match.index !== void 0 ? match.index : value.length;
      code = value.charCodeAt(endPosition);
      if (!match) {
        buffer = value.slice(startPosition);
        break;
      }
      if (code === 10 && startPosition === endPosition && atCarriageReturn) {
        chunks.push(-3);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(-5);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        switch (code) {
          case 0: {
            chunks.push(65533);
            column++;
            break;
          }
          case 9: {
            next = Math.ceil(column / 4) * 4;
            chunks.push(-2);
            while (column++ < next)
              chunks.push(-1);
            break;
          }
          case 10: {
            chunks.push(-4);
            column = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn)
        chunks.push(-5);
      if (buffer)
        chunks.push(buffer);
      chunks.push(null);
    }
    return chunks;
  }
}

// node_modules/micromark-util-decode-string/index.js
var characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value) {
  return value.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $2) {
  if ($1) {
    return $1;
  }
  const head = $2.charCodeAt(0);
  if (head === 35) {
    const head2 = $2.charCodeAt(1);
    const hex = head2 === 120 || head2 === 88;
    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);
  }
  return decodeNamedCharacterReference($2) || $0;
}

// node_modules/unist-util-stringify-position/lib/index.js
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position(value.position);
  }
  if ("start" in value || "end" in value) {
    return position(value);
  }
  if ("line" in value || "column" in value) {
    return point(value);
  }
  return "";
}
function point(point3) {
  return index(point3 && point3.line) + ":" + index(point3 && point3.column);
}
function position(pos) {
  return point(pos && pos.start) + "-" + point(pos && pos.end);
}
function index(value) {
  return value && typeof value === "number" ? value : 1;
}

// node_modules/mdast-util-from-markdown/lib/index.js
var own = {}.hasOwnProperty;
function fromMarkdown(value, encoding, options) {
  if (typeof encoding !== "string") {
    options = encoding;
    encoding = void 0;
  }
  return compiler(options)(postprocess(parse(options).document().write(preprocess()(value, encoding, true))));
}
function compiler(options) {
  const config = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: opener(link),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading),
      blockQuote: opener(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer,
      codeFencedFenceMeta: buffer,
      codeIndented: opener(codeFlow, buffer),
      codeText: opener(codeText2, buffer),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition2),
      definitionDestinationString: buffer,
      definitionLabelString: buffer,
      definitionTitleString: buffer,
      emphasis: opener(emphasis),
      hardBreakEscape: opener(hardBreak),
      hardBreakTrailing: opener(hardBreak),
      htmlFlow: opener(html, buffer),
      htmlFlowData: onenterdata,
      htmlText: opener(html, buffer),
      htmlTextData: onenterdata,
      image: opener(image),
      label: buffer,
      link: opener(link),
      listItem: opener(listItem),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list2, onenterlistordered),
      listUnordered: opener(list2),
      paragraph: opener(paragraph),
      reference: onenterreference,
      referenceString: buffer,
      resourceDestinationString: buffer,
      resourceTitleString: buffer,
      setextHeading: opener(heading),
      strong: opener(strong),
      thematicBreak: opener(thematicBreak2)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  };
  configure(config, (options || {}).mdastExtensions || []);
  const data = {};
  return compile;
  function compile(events) {
    let tree = {
      type: "root",
      children: []
    };
    const context = {
      stack: [tree],
      tokenStack: [],
      config,
      enter,
      exit: exit2,
      buffer,
      resume,
      data
    };
    const listStack = [];
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "listOrdered" || events[index2][1].type === "listUnordered") {
        if (events[index2][0] === "enter") {
          listStack.push(index2);
        } else {
          const tail = listStack.pop();
          index2 = prepareList(events, tail, index2);
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      const handler = config[events[index2][0]];
      if (own.call(handler, events[index2][1].type)) {
        handler[events[index2][1].type].call(Object.assign({
          sliceSerialize: events[index2][2].sliceSerialize
        }, context), events[index2][1]);
      }
    }
    if (context.tokenStack.length > 0) {
      const tail = context.tokenStack[context.tokenStack.length - 1];
      const handler = tail[1] || defaultOnError;
      handler.call(context, void 0, tail[0]);
    }
    tree.position = {
      start: point2(events.length > 0 ? events[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: point2(events.length > 0 ? events[events.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    };
    index2 = -1;
    while (++index2 < config.transforms.length) {
      tree = config.transforms[index2](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start, length) {
    let index2 = start - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem2;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index2 <= length) {
      const event = events[index2];
      switch (event[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          if (event[0] === "enter") {
            containerBalance++;
          } else {
            containerBalance--;
          }
          atMarker = void 0;
          break;
        }
        case "lineEndingBlank": {
          if (event[0] === "enter") {
            if (listItem2 && !atMarker && !containerBalance && !firstBlankLineIndex) {
              firstBlankLineIndex = index2;
            }
            atMarker = void 0;
          }
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace": {
          break;
        }
        default: {
          atMarker = void 0;
        }
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
        if (listItem2) {
          let tailIndex = index2;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
              if (tailEvent[0] === "exit")
                continue;
              if (lineIndex) {
                events[lineIndex][1].type = "lineEndingBlank";
                listSpread = true;
              }
              tailEvent[1].type = "lineEnding";
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent") {
            } else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem2._spread = true;
          }
          listItem2.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);
          events.splice(lineIndex || index2, 0, ["exit", listItem2, event[2]]);
          index2++;
          length++;
        }
        if (event[1].type === "listItemPrefix") {
          const item = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start),
            end: void 0
          };
          listItem2 = item;
          events.splice(index2, 0, ["enter", item, event[2]]);
          index2++;
          length++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start][1]._spread = listSpread;
    return length;
  }
  function opener(create, and) {
    return open;
    function open(token) {
      enter.call(this, create(token), token);
      if (and)
        and.call(this, token);
    }
  }
  function buffer() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function enter(node2, token, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    const siblings = parent.children;
    siblings.push(node2);
    this.stack.push(node2);
    this.tokenStack.push([token, errorHandler]);
    node2.position = {
      start: point2(token.start),
      end: void 0
    };
  }
  function closer(and) {
    return close;
    function close(token) {
      if (and)
        and.call(this, token);
      exit2.call(this, token);
    }
  }
  function exit2(token, onExitError) {
    const node2 = this.stack.pop();
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error("Cannot close `" + token.type + "` (" + stringifyPosition({
        start: token.start,
        end: token.end
      }) + "): it\u2019s not open");
    } else if (open[0].type !== token.type) {
      if (onExitError) {
        onExitError.call(this, token, open[0]);
      } else {
        const handler = open[1] || defaultOnError;
        handler.call(this, token, open[0]);
      }
    }
    node2.position.end = point2(token.end);
  }
  function resume() {
    return toString(this.stack.pop());
  }
  function onenterlistordered() {
    this.data.expectingFirstListItemValue = true;
  }
  function onenterlistitemvalue(token) {
    if (this.data.expectingFirstListItemValue) {
      const ancestor = this.stack[this.stack.length - 2];
      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
      this.data.expectingFirstListItemValue = void 0;
    }
  }
  function onexitcodefencedfenceinfo() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.lang = data2;
  }
  function onexitcodefencedfencemeta() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.meta = data2;
  }
  function onexitcodefencedfence() {
    if (this.data.flowCodeInside)
      return;
    this.buffer();
    this.data.flowCodeInside = true;
  }
  function onexitcodefenced() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    this.data.flowCodeInside = void 0;
  }
  function onexitcodeindented() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.label = label;
    node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.title = data2;
  }
  function onexitdefinitiondestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.url = data2;
  }
  function onexitatxheadingsequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    if (!node2.depth) {
      const depth = this.sliceSerialize(token).length;
      node2.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    this.data.setextHeadingSlurpLineEnding = true;
  }
  function onexitsetextheadinglinesequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    node2.depth = this.sliceSerialize(token).codePointAt(0) === 61 ? 1 : 2;
  }
  function onexitsetextheading() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function onenterdata(token) {
    const node2 = this.stack[this.stack.length - 1];
    const siblings = node2.children;
    let tail = siblings[siblings.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text3();
      tail.position = {
        start: point2(token.start),
        end: void 0
      };
      siblings.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token) {
    const tail = this.stack.pop();
    tail.value += this.sliceSerialize(token);
    tail.position.end = point2(token.end);
  }
  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const tail = context.children[context.children.length - 1];
      tail.position.end = point2(token.end);
      this.data.atHardBreak = void 0;
      return;
    }
    if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }
  function onexithardbreak() {
    this.data.atHardBreak = true;
  }
  function onexithtmlflow() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexithtmltext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexitcodetext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexitlink() {
    const node2 = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitimage() {
    const node2 = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitlabeltext(token) {
    const string3 = this.sliceSerialize(token);
    const ancestor = this.stack[this.stack.length - 2];
    ancestor.label = decodeString(string3);
    ancestor.identifier = normalizeIdentifier(string3).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    const value = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    this.data.inReference = true;
    if (node2.type === "link") {
      const children = fragment.children;
      node2.children = children;
    } else {
      node2.alt = value;
    }
  }
  function onexitresourcedestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.url = data2;
  }
  function onexitresourcetitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.title = data2;
  }
  function onexitresource() {
    this.data.inReference = void 0;
  }
  function onenterreference() {
    this.data.referenceType = "collapsed";
  }
  function onexitreferencestring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.label = label;
    node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
    this.data.referenceType = "full";
  }
  function onexitcharacterreferencemarker(token) {
    this.data.characterReferenceType = token.type;
  }
  function onexitcharacterreferencevalue(token) {
    const data2 = this.sliceSerialize(token);
    const type = this.data.characterReferenceType;
    let value;
    if (type) {
      value = decodeNumericCharacterReference(data2, type === "characterReferenceMarkerNumeric" ? 10 : 16);
      this.data.characterReferenceType = void 0;
    } else {
      const result = decodeNamedCharacterReference(data2);
      value = result;
    }
    const tail = this.stack.pop();
    tail.value += value;
    tail.position.end = point2(token.end);
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    node2.url = this.sliceSerialize(token);
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    node2.url = "mailto:" + this.sliceSerialize(token);
  }
  function blockQuote2() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function codeFlow() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function codeText2() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function definition2() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function heading() {
    return {
      type: "heading",
      depth: 0,
      children: []
    };
  }
  function hardBreak() {
    return {
      type: "break"
    };
  }
  function html() {
    return {
      type: "html",
      value: ""
    };
  }
  function image() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function link() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function list2(token) {
    return {
      type: "list",
      ordered: token.type === "listOrdered",
      start: null,
      spread: token._spread,
      children: []
    };
  }
  function listItem(token) {
    return {
      type: "listItem",
      spread: token._spread,
      checked: null,
      children: []
    };
  }
  function paragraph() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function strong() {
    return {
      type: "strong",
      children: []
    };
  }
  function text3() {
    return {
      type: "text",
      value: ""
    };
  }
  function thematicBreak2() {
    return {
      type: "thematicBreak"
    };
  }
}
function point2(d) {
  return {
    line: d.line,
    column: d.column,
    offset: d.offset
  };
}
function configure(combined, extensions) {
  let index2 = -1;
  while (++index2 < extensions.length) {
    const value = extensions[index2];
    if (Array.isArray(value)) {
      configure(combined, value);
    } else {
      extension(combined, value);
    }
  }
}
function extension(combined, extension2) {
  let key;
  for (key in extension2) {
    if (own.call(extension2, key)) {
      switch (key) {
        case "canContainEols": {
          const right = extension2[key];
          if (right) {
            combined[key].push(...right);
          }
          break;
        }
        case "transforms": {
          const right = extension2[key];
          if (right) {
            combined[key].push(...right);
          }
          break;
        }
        case "enter":
        case "exit": {
          const right = extension2[key];
          if (right) {
            Object.assign(combined[key], right);
          }
          break;
        }
      }
    }
  }
}
function defaultOnError(left, right) {
  if (left) {
    throw new Error("Cannot close `" + left.type + "` (" + stringifyPosition({
      start: left.start,
      end: left.end
    }) + "): a different token (`" + right.type + "`, " + stringifyPosition({
      start: right.start,
      end: right.end
    }) + ") is open");
  } else {
    throw new Error("Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({
      start: right.start,
      end: right.end
    }) + ") is still open");
  }
}

// src/utils.ts
var import_obsidian = require("obsidian");
var fixSpaceInName = (name) => {
  return name.replace(/[\u00A0\u1680\u180E\u2000-\u200B\u202F\u205F\u3000\uFEFF]/, " ").trim();
};
var getNoteByName = async (app2, path) => {
  const file = app2.vault.getAbstractFileByPath(path);
  if (!(file instanceof import_obsidian.TFile))
    return "";
  return await app2.vault.cachedRead(file);
};
var formatDateNow = () => {
  const d = new Date();
  const day = d.getDate();
  let hr = d.getHours();
  let min = d.getMinutes();
  const month = d.getMonth() + 1;
  const year = d.getFullYear();
  const seconds = d.getSeconds();
  return `${year}_${month}_${day}_${hr}_${min}_${seconds}`;
};

// src/latex-template/template.ts
var LatexTemplate = class {
};

// src/latex-template/latex-style.ts
var latex_style_default = `
%%%%%%%%%%%%%%%%%%%%%%%% latexstyle.sty
%
%  Styl pro sazbu diplomovych praci pro XeLaTeX, v. 2.1
%  Freeware.
%  Omezeni: Pokud kdokoliv provede jakoukoliv modifikaci,
%           nesmi styl sirit pod stejnym jmenem.
%
%  Jiri Rybicka, 27. 4. 2019
%
%%%%%%%%%%%%%%%%%%%%%%%%
%
%  TEST SPRAVNOSTI KODOVANI (kodovani je UTF-8)
%  ---------------------------------------
%  P\u0159\xEDli\u0161 \u017Elu\u0165ou\u010Dk\xFD k\u016F\u0148 \xFAp\u011Bl \u010F\xE1belsk\xE9 \xF3dy.
%  ---------------------------------------
%  Predchozi vetu musite videt spravne.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Historie:
%
% 27. 4. 2019 -- verze 2.1: 
%       a) zm\u011Bna sazby seznamu obr\xE1zk\u016F a tabulek
%       b) definice cleardoublepage -- nezobrazuje \u010D\xEDslo str\xE1nky na pr\xE1zdn\xE9 stran\u011B
% 21. 3. 2019 -- verze 2.0, po\u010D\xE1te\u010Dn\xED

\\usepackage{listings}


%%%%%%%%%%%%%%%%%%%%%% Vno\u0159en\xE9 styly

\\usepackage[no-math]{mathspec}
\\usepackage{graphicx, polyglossia, xltxtra, xcolor}

%%%%%%%%%%%%%%%%%%%%%% Rozm\u011Brov\xE9 parametry

\\textwidth 150mm \\hoffset -5mm
\\textheight 220mm \\voffset -5mm
\\oddsidemargin 14mm
\\evensidemargin 6mm

\\tolerance 4000
\\widowpenalty 5000
\\clubpenalty 5000
\\raggedbottom

\\newlength\\intparindent
\\newlength\\intparskip
\\def\\technika{\\parindent=0pt \\parskip=0.5\\baselineskip plus 1pt}
\\def\\beletrie{\\parindent=2em \\parskip=0pt}

\\beletrie % implicitn\u011B
%%%%%%%%%%%%%%%%%%%%%% Fonty

\\def\\pismo#1{\\csname f@#1\\endcsname}

\\def\\f@LModern{} % Latin Modern je implicitn\u011B
\\def\\f@Academica{\\setprimaryfont{Academica Text Pro}\\setallsansfonts{Tahoma}\\setmonofont[Scale=0.9]{Consolas}}
\\def\\f@Baskerville{\\setprimaryfont{Baskerville 10 Pro}\\setallsansfonts{John Sans Text Pro}\\setmonofont[Scale=0.9]{Consolas}}
\\def\\f@Bookman{\\setprimaryfont{TeX Gyre Bonum}\\setallsansfonts{Verdana}%
		\\setmonofont[Scale=0.9]{TeX Gyre Cursor}[FakeBold=1.5]}
\\def\\f@Cambria{\\setprimaryfont{Cambria}\\setallsansfonts{Calibri}\\setmonofont[Scale=0.9]{Consolas}}
\\def\\f@Comenia{\\setprimaryfont{Comenia Serif Pro}\\setallsansfonts{Candara}\\setmonofont[Scale=0.9]{Consolas}}
\\def\\f@Constantia{\\setprimaryfont{Constantia}\\setallsansfonts{Candara}\\setmonofont[Scale=0.9]{Consolas}}
\\def\\f@Palatino{\\setprimaryfont{TeX Gyre Pagella}\\setallsansfonts{TeX Gyre Heros}%
		\\setmonofont[Scale=0.9]{Consolas}}
\\def\\f@Times{\\setprimaryfont{TeX Gyre Termes}\\setallsansfonts{TeX Gyre Heros}%
		\\setmonofont[Scale=0.8]{TeX Gyre Cursor}[FakeBold=1.5]}

\\defaultfontfeatures{Mapping=tex-text}

\\def\\jedenfont{\\let\\doplsanserif\\relax}
\\def\\dvafonty{\\let\\doplsanserif\\sffamily}

\\jedenfont % implicitn\u011B

\\def\\markfont{\\normalfont\\footnotesize\\doplsanserif}
\\def\\pgfont{\\normalfont\\bfseries\\doplsanserif}

%%%%%%%%%%%%%%%%%%%%%% Str\xE1nkov\xE1n\xED

\\def\\ps@headings{%
		\\def\\@oddfoot{}%
		\\def\\@evenfoot{}%
		\\let\\@mkboth\\markboth
		\\def\\@evenhead{\\parbox{\\textwidth}{{\\pgfont \\thepage}
				\\hfill{\\markfont \\leftmark}\\smallskip\\hrule}}%
		\\def\\@oddhead{\\parbox{\\textwidth}{{\\markfont
		\\rightmark}\\hfill{\\pgfont \\thepage}\\smallskip\\hrule}}}

\\def\\ps@plain{%
		\\def\\@oddhead{}%
		\\def\\@evenhead{}%
		\\def\\@evenfoot{\\parbox{\\textwidth}{\\pgfont \\thepage}}%
		\\def\\@oddfoot{\\parbox{\\textwidth}{\\hspace*{\\fill}
					{\\pgfont \\thepage}}}}

\\def\\ps@empty{\\def\\@oddhead{}%
				\\def\\@evenhead{}%
				\\def\\@oddfoot{}%
				\\def\\@evenfoot{}%
				}
\\def\\ps@notext{%
		\\def\\@oddfoot{}%
		\\def\\@evenfoot{}%
		\\def\\@evenhead{}%
		\\def\\@oddhead{\\parbox{\\textwidth}{{Seznam pou\u017Eit\xFDch zkratek}\\hfill{\\pgfont \\thepage}\\smallskip\\hrule}}}

\\pagestyle{headings}   % implicitn\u011B

\\def\\cleardoublepage{\\clearpage\\thispagestyle{empty}\\if@twoside \\ifodd\\c@page\\else
	\\hbox{}\\newpage\\if@twocolumn\\hbox{}\\newpage\\fi\\fi\\fi}

%%%%%%%%%%%%%%%%%%%%%% Jazyky
\\setmainlanguage{czech}
\\setotherlanguage{slovak}
\\setotherlanguage{english}

\\def\\cestina{\\gdef\\@jazyk{c}\\selectlanguage{czech}}
\\def\\slovencina{\\gdef\\@jazyk{s}\\selectlanguage{slovak}}
\\def\\english{\\gdef\\@jazyk{a}\\selectlanguage{english}\\let\\uv\\enguv}

\\def\\lokcestina{\\def\\@jazyk{c}\\selectlanguage{czech}}
\\def\\lokslovencina{\\def\\@jazyk{s}\\selectlanguage{slovak}}
\\def\\lokenglish{\\def\\@jazyk{a}\\selectlanguage{english}\\let\\uv\\enguv}

\\def\\@nastavjazyk{\\if c\\@jazyk\\selectlanguage{czech}\\fi
				\\if s\\@jazyk\\selectlanguage{slovak}\\fi
				\\if a\\@jazyk\\selectlanguage{english}\\fi}

\\cestina % implicitn\u011B

\\def\\lgtxt#1{\\if c\\@jazyk\\csname c@#1\\endcsname\\fi
				\\if s\\@jazyk\\csname s@#1\\endcsname\\fi
				\\if a\\@jazyk\\csname a@#1\\endcsname\\fi}

%%%%%%%%%%%%%%%%%%%%%% \xDAvodn\xED str\xE1nky

\\def\\typprace{\\lgtxt{Bakalarska}} % implicitn\xED nastaven\xED
\\def\\bakalarska{\\gdef\\typprace{\\lgtxt{Bakalarska}}}
\\def\\diplomova{\\gdef\\typprace{\\lgtxt{Diplomova}}}
\\def\\disertacni{\\gdef\\typprace{\\lgtxt{Disertacni}}}
\\def\\vedecky{\\gdef\\typprace{\\lgtxt{Vedecky}}}
\\def\\skola#1{\\gdef\\@skola{#1}}
\\def\\fakulta#1{\\gdef\\@fakulta{#1}}

\\def\\titul#1#2#3#4{\\thispagestyle{empty}%
	\\@nastavjazyk
	\\vspace*{-20mm}
	\\begin{center}
	{\\Large \\doplsanserif \\@skola\\\\[8pt]}
	{\\Large \\doplsanserif \\@fakulta} \\par \\bigskip \\hrule
	\\vbox to 165mm{\\vspace*{\\fill}
	{\\Huge\\doplsanserif\\bfseries #1\\par}\\vskip 10mm
	{\\large\\doplsanserif\\bfseries \\typprace{} } \\par
	\\vspace*{\\fill}}\\par
	\\noindent {\\large \\doplsanserif
		\\begin{tabular}{@{}l}
		\\lgtxt{Vedprace}:\\\\ #3\\end{tabular} \\hfill #2}
	\\par \\vfill {\\large \\doplsanserif #4}\\end{center}%
	\\gdef\\@nazprace{#1}%
}

\\skola{\\lgtxt{Mendelka}}
\\fakulta{\\lgtxt{Pefka}}

\\def\\prohlaseni#1#2{\\cleardoublepage\\thispagestyle{empty}\\vspace*{\\fill}\\noindent
		\\parbox{\\textwidth}{\\hspace*{\\parindent}#1 \\\\[15mm]
		#2 \\hfill \\hbox to 60mm{\\tiny\\dotfill}}}

\\def\\prohlasenizena#1{\\cleardoublepage\\intparindent=\\parindent\\intparskip=\\parskip
		\\thispagestyle{empty}\\vspace*{\\fill}\\noindent
		\\parbox{\\textwidth}{\\doplsanserif\\bfseries \\lgtxt{Cprohlas}}\\par\\medskip
		\\noindent\\lgtxt{Prohltextzena}\\\\[15mm]
		#1 \\hfill \\begin{tabular}[t]{c@{}}\\hbox to 60mm{\\tiny\\dotfill}\\\\
					\\footnotesize\\lgtxt{podpis}\\end{tabular}}

\\def\\prohlasenimuz#1{\\cleardoublepage\\intparindent=\\parindent\\intparskip=\\parskip
		\\thispagestyle{empty}\\vspace*{\\fill}\\noindent
		\\parbox{\\textwidth}{\\doplsanserif\\bfseries \\lgtxt{Cprohlas}}\\par\\medskip
		\\noindent\\lgtxt{Prohltextmuz}\\\\[15mm]
		#1 \\hfill \\begin{tabular}[t]{c@{}}\\hbox to 60mm{\\tiny\\dotfill}\\\\
					\\footnotesize\\lgtxt{podpis}\\end{tabular}}

\\def\\podekovani#1{\\cleardoublepage\\thispagestyle{empty}\\vspace*{\\fill}%
		\\noindent\\parbox{\\textwidth}{{\\doplsanserif\\bfseries \\lgtxt{Podekovani}}\\par\\medskip
		#1}}

\\def\\abstract#1#2{\\gdef\\@enabstraktdata{#1}\\gdef\\@enabstrakttext{#2}}
\\def\\abstrakt#1#2{\\gdef\\@csabstraktdata{#1}\\gdef\\@csabstrakttext{#2}}

\\def\\klslova#1{\\gdef\\@csklslova{#1}}
\\def\\keywords#1{\\gdef\\@enklslova{#1}}

\\abstract..
\\abstrakt..
\\klslova. % implicitn\u011B jen te\u010Dka, kter\xE1 se testuje na p\u0159\xEDtomnost obsahu
\\keywords.

\\def\\@vypisabstrakty{\\cleardoublepage\\vspace*{5mm}%
		\\if a\\@jazyk
			{\\lokcestina\\noindent {\\doplsanserif\\bfseries Abstrakt}\\par\\medskip
			\\noindent \\@csabstraktdata\\par\\medskip\\noindent\\@csabstrakttext
			\\if .\\@csklslova\\else \\par\\medskip\\noindent
				{\\doplsanserif\\bfseries\\lgtxt{Klslova}:} \\@csklslova
			\\fi
			}
			\\par\\vspace{2cm}%
			\\noindent {\\doplsanserif\\bfseries Abstract}\\par\\medskip
			\\noindent \\@enabstraktdata\\par\\medskip\\noindent\\@enabstrakttext
			\\if .\\@enklslova\\else \\par\\medskip\\noindent
				{\\doplsanserif\\bfseries\\lgtxt{Klslova}:} \\@enklslova
			\\fi
		\\else
			{\\lokenglish
			\\noindent {\\doplsanserif\\bfseries Abstract}\\par\\medskip
			\\noindent \\@enabstraktdata\\par\\medskip\\noindent\\@enabstrakttext
			\\if .\\@enklslova\\else \\par\\medskip\\noindent
				{\\doplsanserif\\bfseries\\lgtxt{Klslova}:} \\@enklslova
			\\fi}
			\\par\\vspace{2cm}%
			\\noindent {\\doplsanserif\\bfseries Abstrakt}\\par\\medskip
			\\noindent \\@csabstraktdata\\par\\medskip\\noindent\\@csabstrakttext
			\\if .\\@csklslova\\else \\par\\medskip\\noindent
				{\\doplsanserif\\bfseries\\lgtxt{Klslova}:} \\@csklslova
			\\fi
		\\fi}

%%%%%%%%%%%%%%%%%%%%%% Obsah

\\def\\obsah{\\@vypisabstrakty\\cleardoublepage\\tableofcontents\\cleardoublepage}

\\def\\l@obrtab#1#2{\\addpenalty{\\@secpenalty}% good place for page break
	\\addvspace{0.2em plus\\p@}%
	\\@tempdima 1.5em
	\\begingroup
		\\parindent \\z@ \\rightskip \\@pnumwidth plus 1in
		\\parfillskip -\\@pnumwidth
		\\leavevmode
		\\advance\\leftskip\\@tempdima
		\\hskip -\\leftskip
		#1\\nobreak
		\\xleaders\\hbox{$\\m@th
		\\mkern \\@dotsep mu\\hbox{.}\\mkern \\@dotsep
		mu$}\\hfill\\nobreak\\hbox to\\@pnumwidth{\\hss #2}\\par
	\\endgroup}

%%%%%%%%%%%%%%%%%%%%%% Odd\xEDly v textu

\\def\\cislovat#1{\\setcounter{secnumdepth}{#1}\\setcounter{tocdepth}{#1}}

\\renewcommand\\section{\\@startsection {section}{1}{\\z@}%
					{-3.5ex \\@plus -1ex \\@minus -.2ex}%
					{2.3ex \\@plus.2ex}%
					{\\normalfont\\doplsanserif\\Large\\bfseries}}
\\renewcommand\\subsection{\\@startsection{subsection}{2}{\\z@}%
					{-3.25ex\\@plus -1ex \\@minus -.2ex}%
					{1.5ex \\@plus .2ex}%
					{\\normalfont\\doplsanserif\\large\\bfseries}}
\\renewcommand\\subsubsection{\\@startsection{subsubsection}{3}{\\z@}%
					{-3.25ex\\@plus -1ex \\@minus -.2ex}%
					{1.5ex \\@plus .2ex}%
					{\\normalfont\\normalsize\\doplsanserif\\bfseries}}
\\renewcommand\\paragraph{\\@startsection{paragraph}{4}{\\z@}%
					{3.25ex \\@plus1ex \\@minus.2ex}%
					{-1em}%
					{\\normalfont\\normalsize\\doplsanserif\\bfseries}}
\\renewcommand\\subparagraph{\\@startsection{subparagraph}{5}{\\parindent}%
					{3.25ex \\@plus1ex \\@minus .2ex}%
					{-1em}%
					{\\normalfont\\normalsize\\doplsanserif\\bfseries}}


\\renewcommand\\lstlistingname{Seznam k\xF3d\u016F} % p\u0159edefinov\xE1n\xED nadpisu
\\renewcommand\\lstlistlistingname{Seznam k\xF3d\u016F} % p\u0159edefinov\xE1n\xED nadpisu v obsahu
% \\newcommand\\listequationsname{Seznam rovnic}

\\def\\kapitola#1{\\clearpage\\section{#1}
		\\markboth{\\thesection\\quad \\uppercase{#1}}{\\thesection\\quad
								\\uppercase{#1}}}
\\def\\sekce#1{\\subsection{#1}\\markright{\\thesubsection\\quad #1}}
\\def\\podsekce#1{\\subsubsection{#1}}

\\def\\appname{\\lgtxt{Prilohy}}

\\def\\@samstranapriloh{\\clearpage\\thispagestyle{empty}
		\\vspace*{50mm}\\begin{center}
		\\normalfont\\doplsanserif\\LARGE\\bfseries
					\\uppercase{\\appname}\\end{center}
		\\addcontentsline{toc}{section}{\\appname}
}

\\def\\prilohy{\\@ifnextchar*{\\@prilohy{}}{\\@prilohy{\\@samstranapriloh}}}

\\def\\@prilohy#1{#1
		\\def\\thesection{\\Alph{section}}\\setcounter{section}{0}}
\\let\\priloha\\kapitola


%%%%%%%%%%%%%%%%%%%%%% Literatura

\\def\\refname#1{\\gdef\\@nadpliter{#1}}
\\gdef\\@nadpliter{\\lgtxt{Literatura}}

\\renewenvironment{thebibliography}[1]
		{\\section{\\@nadpliter}%
		\\markboth{\\thesection\\quad \\uppercase{\\@nadpliter}}{\\thesection\\quad
									\\uppercase{\\@nadpliter}}%
		\\list{\\@biblabel{\\@arabic\\c@enumiv}}%
			{\\settowidth\\labelwidth{\\@biblabel{#1}}%
			\\itemindent -2em
			\\leftmargin 2em
			\\raggedright
			\\@openbib@code
			%\\usecounter{enumiv}%
			\\let\\p@enumiv\\@empty
			\\renewcommand\\theenumiv{\\@arabic\\c@enumiv}}%
		\\sloppy
		\\clubpenalty4000
		\\@clubpenalty \\clubpenalty
		\\widowpenalty4000%
		\\sfcode\`\\.\\@m}

\\def\\@citex[#1]#2{%
	\\let\\@citea\\@empty
	\\@cite{\\@for\\@citeb:=#2\\do
	{\\@citea\\def\\@citea{; }%
		\\edef\\@citeb{\\expandafter\\@firstofone\\@citeb}%
		\\if@filesw\\immediate\\write\\@auxout{\\string\\citation{\\@citeb}}\\fi
		\\@ifundefined{b@\\@citeb}{\\mbox{\\reset@font\\bfseries ?}%
		\\G@refundefinedtrue
		\\@latex@warning
			{Citation \`\\@citeb' on page \\thepage \\space undefined}}%
		{\\hbox{\\csname b@\\@citeb\\endcsname}}}}{#1}}

\\def\\@lbibitem[#1]#2{\\item []\\if@filesw
		{\\let\\protect\\noexpand
		\\immediate
		\\write\\@auxout{\\string\\bibcite{#2}{#1}}}\\fi\\ignorespaces}

\\def\\@cite#1#2{({\\let\\hbox\\relax #1\\if@tempswa , #2\\fi})}

\\def\\autor#1{\\textsc{#1}}
\\def\\nazev#1{\\textit{#1}}
\\def\\akol{\\rm}

\\newenvironment{literatura}{\\newpage\\begin{thebibliography}{}}%
				{\\end{thebibliography}}

\\def\\citace#1#2#3{% ident., tvar odkazu, \xFAdaje
\\bibitem [#2]{#1} #3.
}

%%%%%%%%%%%%%%%%%%%%%% V\xFD\u010Dty a seznamy
\\newdimen\\leftmargini
\\newdimen\\leftmarginii
\\newdimen\\leftmarginiii
\\newdimen\\leftmarginiv
\\newdimen\\leftmarginv
\\newdimen\\leftmarginvi
\\leftmargini=2em
\\leftmarginii=2em
\\leftmarginiii=2em
\\leftmarginiv=2em
\\leftmarginv=2em
\\leftmarginvi=2em

\\def\\@listi{\\leftmargin\\leftmargini
			\\parsep 0pt %\\parskip% 4\\p@ \\@plus2\\p@ \\@minus\\p@
			\\topsep 0.5\\baselineskip%\\parskip% 8\\p@ \\@plus2\\p@ \\@minus4\\p@
			\\itemsep 0.5\\baselineskip}%\\parskip}% 4\\p@ \\@plus2\\p@ \\@minus\\p@}
\\let\\@listI\\@listi
\\@listi
\\def\\@listii {\\leftmargin\\leftmarginii
				\\labelwidth\\leftmarginii
				\\advance\\labelwidth-\\labelsep
				\\topsep   0.5\\baselineskip%\\parskip%  4\\p@ \\@plus2\\p@ \\@minus\\p@
				\\parsep   0pt %\\parskip%  2\\p@ \\@plus\\p@  \\@minus\\p@
				\\itemsep   0.5\\baselineskip}%\\parsep}

\\def\\labelenumii{\\theenumii)}

\\def\\@listiii{\\leftmargin\\leftmarginiii
				\\labelwidth\\leftmarginiii
				\\advance\\labelwidth-\\labelsep
				\\topsep   0.5\\baselineskip%\\parskip%  2\\p@ \\@plus\\p@\\@minus\\p@
				\\parsep   0pt %\\parskip%  \\z@
				\\partopsep\\parskip%  \\p@ \\@plus\\z@ \\@minus\\p@
				\\itemsep   0.5\\baselineskip}%\\topsep}
\\def\\@listiv {\\leftmargin\\leftmarginiv
				\\labelwidth\\leftmarginiv
				\\advance\\labelwidth-\\labelsep}
\\def\\@listv  {\\leftmargin\\leftmarginv
				\\labelwidth\\leftmarginv
				\\advance\\labelwidth-\\labelsep}
\\def\\@listvi {\\leftmargin\\leftmarginvi
				\\labelwidth\\leftmarginvi
				\\advance\\labelwidth-\\labelsep}

%%%%%%%%%%%%%%%%%%%%%% Plovouc\xED prost\u0159ed\xED

\\def\\figurename#1{\\gdef\\@nazobr{#1}}
\\def\\tablename#1{\\gdef\\@naztab{#1}}

\\def\\popisky{\\gdef\\@nazobr{\\lgtxt{Obrazek}}\\gdef\\@naztab{\\lgtxt{Tabulka}}}
\\def\\popiskyzkr{\\gdef\\@nazobr{\\lgtxt{Obr}}\\gdef\\@naztab{\\lgtxt{Tab}}}

\\popisky % implicitn\u011B

\\def\\csfigcap#1{\\refstepcounter{figure}\\parbox{\\textwidth}{\\small\\raggedright%
		\\@nazobr{} \\thefigure: #1}\\addcontentsline{lof}{obrtab}{\\figurename{} 
		\\thefigure: #1}}

\\def\\obrzdroj#1{\\newline\\textit{\\lgtxt{Zdroj}:} #1}

\\def\\csfigcapbez{\\refstepcounter{figure}\\parbox{\\textwidth}{\\small%
		\\@nazobr{} \\thefigure}\\addcontentsline{lof}{obrtab}{\\figurename{} 
		\\thefigure}}

\\def\\cstabcap#1{\\refstepcounter{table}\\parbox{\\textwidth}{\\small\\raggedright%
		\\@naztab{} \\thetable: #1}\\addcontentsline{lot}{obrtab}{\\tablename{} 
		\\thetable: #1}}

\\def\\cstabcapbez{\\refstepcounter{table}\\parbox{\\textwidth}{\\small%
		\\@naztab{} \\thetable}\\addcontentsline{lot}{obrtab}{\\tablename{} 
		\\thetable}}
		
\\def\\tabzdroj#1{\\par\\medskip\\parbox{\\textwidth}{\\small\\textit{\\lgtxt{Zdroj}:} #1}}       

\\newif\\ifjedraft\\jedraftfalse
\\def\\draft{\\jedrafttrue}
\\def\\obrazek{\\begin{figure}[htb]\\centering }
\\def\\obrazekp{\\begin{figure}[p]\\centering }
\\def\\endobr#1{\\par\\medskip\\csfigcap{#1}\\end{figure}}
\\def\\endobrl#1#2{\\par\\medskip\\csfigcap{#1}\\label{#2}\\end{figure}}
\\def\\endobrbez{\\par\\medskip\\csfigcapbez\\end{figure}}
% \\def\\vloztif#1{\\ifjedraft\\else\\input #1 \\csname set#1\\endcsname\\fi}
\\def\\vlozobr#1#2{\\ifjedraft \\scalebox{#2}{\\includegraphics[draft]{#1}}
		\\else\\scalebox{#2}{\\includegraphics{#1}}\\fi}
\\def\\vlozobrbox#1#2#3{\\ifjedraft\\resizebox{#2}{#3}{\\includegraphics[draft]{#1}}
		\\else\\resizebox{#2}{#3}{\\includegraphics{#1}}\\fi}

\\def\\tabulka#1{\\begin{table}[htb]\\centering\\cstabcap{#1}\\par\\medskip}
\\def\\tabulkap#1{\\begin{table}[p]\\centering\\cstabcap{#1}\\par\\medskip}
\\def\\endtab{\\end{table}}

\\def\\pole#1#2{{\\def\\arraystretch{.95}\\begin{tabular}{@{}#1@{}}
					#2\\end{tabular}}}

\\def\\polet#1#2{{\\def\\arraystretch{.95}\\begin{tabular}[t]{@{}#1@{}}
					#2\\end{tabular}}}

{\\catcode\`\\!=\\active
\\gdef\\vykricnik{\\catcode\`\\!=\\active \\def!{\\hphantom{0}}}
}

%%%%%%%%%%%%%%%%%%%%%% Speci\xE1ln\xED znaky

\\def\\spoj{\\discretionary{-}{-}{-}}
\\def\\az{\\discretionary{}{\\hbox{a\u017E\\ }}{--}}
\\def\\uvv#1{\xBB#1\xAB}
\\def\\uv#1{\u201E#1\u201C}
\\def\\enguv#1{\u201C#1\u201D}
\\def\\,{\\penalty10000\\hskip0.25em}
\\def\\;{\\penalty10000\\hskip0.16666em}

%%%%%%%%%%%%%%%%%%%%%% Jazykov\xE9 \u0159et\u011Bzce

\\def\\c@Diplomova{Diplomov\xE1 pr\xE1ce}
\\def\\s@Diplomova{Diplomov\xE1 pr\xE1ca}
\\def\\a@Diplomova{Diploma thesis}

\\def\\c@Bakalarska{Bakal\xE1\u0159sk\xE1 pr\xE1ce}
\\def\\s@Bakalarska{Bakal\xE1rska pr\xE1ca}
\\def\\a@Bakalarska{Bachelor thesis}

\\def\\c@Disertacni{Diserta\u010Dn\xED pr\xE1ce}
\\def\\s@Disertacni{Dizerta\u010Dn\xE1 pr\xE1ca}
\\def\\a@Disertacni{Dissertation thesis}


\\def\\c@Vedecky{V\u011Bdeck\xFD \u010Dl\xE1nek}
\\def\\s@Vedecky{Vedeck\xFD \u010Dl\xE1nok}
\\def\\a@Vedecky{Scientific article}

\\def\\c@prace{pr\xE1ce}
\\def\\s@prace{pr\xE1ca}
\\def\\a@prace{thesis}

\\def\\c@Mendelka{Mendelova univerzita v~Brn\u011B}
\\def\\s@Mendelka{Mendelova univerzita v~Brne}
\\def\\a@Mendelka{Mendel University in Brno}

\\def\\c@Pefka{Provozn\u011B ekonomick\xE1 fakulta}
\\def\\s@Pefka{Prev\xE1dzkovo ekonomick\xE1 fakulta}
\\def\\a@Pefka{Faculty of Business and Economy}

\\def\\c@Vedprace{Vedouc\xED pr\xE1ce}
\\def\\s@Vedprace{Ved\xFAci pr\xE1ce}
\\def\\a@Vedprace{Supervisor}

\\def\\c@Prilohy{P\u0159\xEDlohy}
\\def\\s@Prilohy{Pr\xEDlohy}
\\def\\a@Prilohy{Appendices}

\\def\\c@Podekovani{Pod\u011Bkov\xE1n\xED}
\\def\\s@Podekovani{Po\u010Fakovanie}
\\def\\a@Podekovani{Acknowledgment}

\\def\\c@Cprohlas{\u010Cestn\xE9 prohl\xE1\u0161en\xED}
\\def\\s@Cprohlas{\u010Cestn\xE9 prehl\xE1senie}
\\def\\a@Cprohlas{Declaration}

\\def\\c@Prohltextzena{Prohla\u0161uji, \u017Ee jsem pr\xE1ci {\\bfseries \\@nazprace}
		vypracovala samostatn\u011B a~ve\u0161ker\xE9 pou\u017Eit\xE9 prameny a~informace uv\xE1d\xEDm 
		v~seznamu pou\u017Eit\xE9 literatury. Souhlas\xEDm, aby moje pr\xE1ce byla zve\u0159ejn\u011Bna 
		v~souladu s~\xA7\\,47b z\xE1kona \u010D.\\,111/1998 Sb., o~vysok\xFDch \u0161kol\xE1ch ve zn\u011Bn\xED 
		pozd\u011Bj\u0161\xEDch p\u0159edpis\u016F a~v~souladu s~platnou Sm\u011Brnic\xED o~zve\u0159ej\u0148ov\xE1n\xED 
		z\xE1v\u011Bre\u010Dn\xFDch prac\xED.\\par
		\\vskip\\intparskip Jsem si v\u011Bdoma, \u017Ee se na moji pr\xE1ci vztahuje z\xE1kon 
		\u010D.\\,121/2000 Sb., autorsk\xFD z\xE1kon, a~\u017Ee Mendelova univerzita v~Brn\u011B m\xE1 
		pr\xE1vo na uzav\u0159en\xED licen\u010Dn\xED smlouvy a~u\u017Eit\xED t\xE9to pr\xE1ce jako \u0161koln\xEDho d\xEDla 
		podle \xA7\\,60 odst.\\,1 autorsk\xE9ho z\xE1kona.\\par
		\\vskip\\intparskip D\xE1le se zavazuji, \u017Ee p\u0159ed seps\xE1n\xEDm licen\u010Dn\xED smlouvy 
		o~vyu\u017Eit\xED d\xEDla jinou osobou (subjektem) si vy\u017E\xE1d\xE1m p\xEDsemn\xE9 stanovisko 
		univerzity, \u017Ee p\u0159edm\u011Btn\xE1 licen\u010Dn\xED smlouva nen\xED v~rozporu s~opr\xE1vn\u011Bn\xFDmi 
		z\xE1jmy univerzity, a~zavazuji se uhradit p\u0159\xEDpadn\xFD p\u0159\xEDsp\u011Bvek na \xFAhradu 
		n\xE1klad\u016F spojen\xFDch se vznikem d\xEDla, a~to a\u017E do jejich skute\u010Dn\xE9 v\xFD\u0161e.
}
\\def\\s@Prohltextzena{Prehlasujem, \u017Ee som pr\xE1cu {\\bfseries \\@nazprace}
		vypracovala samostatne a~v\u0161etky pou\u017Eit\xE9 zdroje a~inform\xE1cie uv\xE1dzam 
		v~zozname pou\u017Eitej literat\xFAry. S\xFAhlas\xEDm, aby moja pr\xE1ca bola zverejnen\xE1 
		v~s\xFAlade s~\xA7\\,47b z\xE1kona \u010D.\\,111/1998 Zb., o~vysok\xFDch \u0161kol\xE1ch v~znen\xED 
		neskor\u0161\xEDch predpisov a~v~s\xFAlade s~platnou \\textit{Sm\u011Brnic\xED o~zve\u0159ej\u0148ov\xE1n\xED 
		z\xE1v\u011Bre\u010Dn\xFDch prac\xED}.\\par
		\\vskip\\intparskip Som si vedom\xE1, \u017Ee sa na moju pr\xE1cu vz\u0165ahuje z\xE1kon 
		\u010D.\\,121/2000 Zb., autorsk\xFD z\xE1kon, a~\u017Ee Mendelova univerzita v~Brne m\xE1 
		pr\xE1vo na uzatvorenie licen\u010Dnej zmluvy a~pou\u017Eitie tejto pr\xE1ce ako \u0161kolsk\xE9ho 
		diela pod\u013Ea \xA7\\,60 odst.\\,1 autorsk\xE9ho z\xE1kona.\\par
		\\vskip\\intparskip \u010Ealej sa zav\xE4zujem, \u017Ee pred sp\xEDsan\xEDm licen\u010Dnej zmluvy 
		o~pou\u017Eit\xED diela inou osobou (subjektom) si vy\u017Eiadam p\xEDsomn\xE9 stanovisko 
		univerzity, \u017Ee predmetn\xE1 licen\u010Dn\xE1 zmluva nie je v rozpore s~opr\xE1vnen\xFDmi 
		z\xE1ujmami univerzity a~zav\xE4zujem sa uhradi\u0165 pr\xEDpadn\xFD pr\xEDspevok na \xFAhradu 
		n\xE1kladov spojen\xFDch so vznikom diela, a~to a\u017E do ich skuto\u010Dnej v\xFD\u0161ky.
}
\\def\\a@Prohltextzena{I hereby declare that this thesis entitled 
		{\\bfseries \\@nazprace} was written and completed by me. I also declare 
		that all the sources and information used to complete the thesis are 
		included in the list of references. I~agree that the thesis could be 
		made public in accordance with Article 47b of Act No.\\,111/1998 Coll., 
		Higher Education Institutions and on Amendments and Supplements to Some 
		Other Acts (the Higher Education Act), and in accordance with the current 
		Directive on publishing of the final thesis.\\par
		\\vskip\\intparskip I am aware that my thesis is written in accordance to 
		Act No.\\,121/2000 Coll., on Copyright and therefore Mendel University 
		in Brno has the right to conclude licence agreements on the utilization 
		of the thesis as a~school work in accordance with Article 60(1) of the 
		Copyright Act.\\par
		\\vskip\\intparskip Before concluding a~licence agreement on utilization of 
		the work by another person, I will request a written statement from the 
		university that the licence agreement is not in contradiction to 
		legitimate interests of the university, and I will also pay a~prospective 
		fee to cover the cost incurred in creating the work to the full amount of 
		such costs.
}

\\def\\c@Prohltextmuz{Prohla\u0161uji, \u017Ee jsem pr\xE1ci {\\bfseries \\@nazprace}
		vypracoval samostatn\u011B a~ve\u0161ker\xE9 pou\u017Eit\xE9 prameny a~informace uv\xE1d\xEDm 
		v~seznamu pou\u017Eit\xE9 literatury. Souhlas\xEDm, aby moje pr\xE1ce byla zve\u0159ejn\u011Bna 
		v~souladu s~\xA7\\,47b z\xE1kona \u010D.\\,111/1998 Sb., o~vysok\xFDch \u0161kol\xE1ch ve zn\u011Bn\xED 
		pozd\u011Bj\u0161\xEDch p\u0159edpis\u016F a~v~souladu s~platnou Sm\u011Brnic\xED o~zve\u0159ej\u0148ov\xE1n\xED 
		z\xE1v\u011Bre\u010Dn\xFDch prac\xED.\\par
		\\vskip\\intparskip Jsem si v\u011Bdom, \u017Ee se na moji pr\xE1ci vztahuje z\xE1kon 
		\u010D.\\,121/2000 Sb., autorsk\xFD z\xE1kon, a~\u017Ee Mendelova univerzita v~Brn\u011B m\xE1 
		pr\xE1vo na uzav\u0159en\xED licen\u010Dn\xED smlouvy a~u\u017Eit\xED t\xE9to pr\xE1ce jako \u0161koln\xEDho d\xEDla 
		podle \xA7\\,60 odst.\\,1 autorsk\xE9ho z\xE1kona.\\par
		\\vskip\\intparskip D\xE1le se zavazuji, \u017Ee p\u0159ed seps\xE1n\xEDm licen\u010Dn\xED smlouvy 
		o~vyu\u017Eit\xED d\xEDla jinou osobou (subjektem) si vy\u017E\xE1d\xE1m p\xEDsemn\xE9 stanovisko 
		univerzity, \u017Ee p\u0159edm\u011Btn\xE1 licen\u010Dn\xED smlouva nen\xED v~rozporu s~opr\xE1vn\u011Bn\xFDmi 
		z\xE1jmy univerzity, a~zavazuji se uhradit p\u0159\xEDpadn\xFD p\u0159\xEDsp\u011Bvek na \xFAhradu 
		n\xE1klad\u016F spojen\xFDch se vznikem d\xEDla, a~to a\u017E do jejich skute\u010Dn\xE9 v\xFD\u0161e.
}
\\def\\s@Prohltextmuz{Prehlasujem, \u017Ee som pr\xE1cu {\\bfseries \\@nazprace}
		vypracoval samostatne a~v\u0161etky pou\u017Eit\xE9 zdroje a~inform\xE1cie uv\xE1dzam 
		v~zozname pou\u017Eitej literat\xFAry. S\xFAhlas\xEDm, aby moja pr\xE1ca bola zverejnen\xE1 
		v~s\xFAlade s~\xA7\\,47b z\xE1kona \u010D.\\,111/1998 Zb., o~vysok\xFDch \u0161kol\xE1ch v~znen\xED 
		neskor\u0161\xEDch predpisov a~v~s\xFAlade s~platnou \\textit{Sm\u011Brnic\xED o~zve\u0159ej\u0148ov\xE1n\xED 
		z\xE1v\u011Bre\u010Dn\xFDch prac\xED}.\\par
		\\vskip\\intparskip Som si vedom\xFD, \u017Ee sa na moju pr\xE1cu vz\u0165ahuje z\xE1kon 
		\u010D.\\,121/2000 Zb., autorsk\xFD z\xE1kon, a~\u017Ee Mendelova univerzita v~Brne m\xE1 
		pr\xE1vo na uzatvorenie licen\u010Dnej zmluvy a~pou\u017Eitie tejto pr\xE1ce ako \u0161kolsk\xE9ho 
		diela pod\u013Ea \xA7\\,60 odst.\\,1 autorsk\xE9ho z\xE1kona.\\par
		\\vskip\\intparskip \u010Ealej sa zav\xE4zujem, \u017Ee pred sp\xEDsan\xEDm licen\u010Dnej zmluvy 
		o~pou\u017Eit\xED diela inou osobou (subjektom) si vy\u017Eiadam p\xEDsomn\xE9 stanovisko 
		univerzity, \u017Ee predmetn\xE1 licen\u010Dn\xE1 zmluva nie je v rozpore s~opr\xE1vnen\xFDmi 
		z\xE1ujmami univerzity a~zav\xE4zujem sa uhradi\u0165 pr\xEDpadn\xFD pr\xEDspevok na \xFAhradu 
		n\xE1kladov spojen\xFDch so vznikom diela, a~to a\u017E do ich skuto\u010Dnej v\xFD\u0161ky.
}
\\def\\a@Prohltextmuz{I hereby declare that this thesis entitled 
		{\\bfseries \\@nazprace} was written and completed by me. I also declare 
		that all the sources and information used to complete the thesis are 
		included in the list of references. I~agree that the thesis could be 
		made public in accordance with Article 47b of Act No.\\,111/1998 Coll., 
		Higher Education Institutions and on Amendments and Supplements to Some 
		Other Acts (the Higher Education Act), and in accordance with the current 
		Directive on publishing of the final thesis.\\par
		\\vskip\\intparskip I am aware that my thesis is written in accordance to 
		Act No.\\,121/2000 Coll., on Copyright and therefore Mendel University 
		in Brno has the right to conclude licence agreements on the utilization 
		of the thesis as a~school work in accordance with Article 60(1) of the 
		Copyright Act.\\par
		\\vskip\\intparskip Before concluding a~licence agreement on utilization of 
		the work by another person, I will request a written statement from the 
		university that the licence agreement is not in contradiction to 
		legitimate interests of the university, and I will also pay a~prospective 
		fee to cover the cost incurred in creating the work to the full amount of 
		such costs.
}

\\def\\c@podpis{podpis}
\\def\\s@podpis{podpis}
\\def\\a@podpis{signature}

\\def\\c@Obr{Obr.}
\\def\\s@Obr{Obr.}
\\def\\a@Obr{Fig.}

\\def\\c@Tab{Tab.}
\\def\\s@Tab{Tab.}
\\def\\a@Tab{Tab.}

\\def\\c@Obrazek{Obr\xE1zek}
\\def\\s@Obrazek{Obr\xE1zok}
\\def\\a@Obrazek{Figure}

\\def\\c@Tabulka{Tabulka}
\\def\\s@Tabulka{Tabu\u013Eka}
\\def\\a@Tabulka{Table}

\\def\\c@Klslova{Kl\xED\u010Dov\xE1 slova}
\\def\\s@Klslova{K\u013E\xFA\u010Dov\xE9 slov\xE1}
\\def\\a@Klslova{Key words}

\\def\\c@Literatura{Literatura}
\\def\\s@Literatura{Literat\xFAra}
\\def\\a@Literatura{References}

\\def\\c@Zdroj{Zdroj}
\\def\\s@Zdroj{Zdroj}
\\def\\a@Zdroj{Source}

\\def\\c@{}
\\def\\s@{}
\\def\\a@{}


\\definecolor{codegreen}{rgb}{0,0.6,0}
\\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\\definecolor{codepurple}{rgb}{0.58,0,0.82}

\\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\\definecolor{deepblue}{rgb}{0,0,0.5}
\\definecolor{deepred}{rgb}{0.6,0,0}
\\definecolor{deepgreen}{rgb}{0,0.5,0}


\\lstdefinestyle{mystyle}{
	commentstyle=\\color{codegreen},
	keywordstyle=\\color{deepblue},
	numberstyle=\\tiny\\color{codegray},
	stringstyle=\\color{deepred},
	basicstyle=\\ttfamily\\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}

\\lstset{style=mystyle}

%%%%%%%%%%%%%%%%%%%%%% konec stylu dipp %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
`;

// src/latex-template/pef.template.ts
var PEFTemplate = class extends LatexTemplate {
  constructor(rawMetadata, settings) {
    super();
    this.metadata = {};
    this.metadataParams = [
      "title",
      "author",
      "supervisor",
      "locationAndDate",
      "acknowledgment",
      "declaration",
      "abstract-title-en",
      "abstract-title-cs",
      "abstract-desc-en",
      "abstract-desc-cs",
      "keywords-en",
      "keywords-cs",
      "thesis"
    ];
    this.allowedTypes = ["bachelor", "master", "dissertation", "scientific"];
    this.settings = settings;
    this.parseMetadata(rawMetadata);
  }
  composeThesis(thesisParts, body, citations, attachments) {
    this.thesisParts = thesisParts;
    return `
%####### Spo\u010D\xEDt\xE1n\xED znak\u016F s mezerami na Linuxu: 
%####### $ pdftotext document.pdf -enc UTF-8 - | wc -m 
% 1 AA = 36 000 znak\u016F = 5 600 - 6 200 slov
% 2,5 AA = 90 000 znak\u016F

\\documentclass[twoside,12pt]{article}%
% pro tisk po jedn\xE9 stran\u011B pap\xEDru je pot\u0159ebn\xE9 odstranit volbu twoside
\\usepackage{latexstyle}
\\usepackage{graphicx} %package to manage images
\\graphicspath{ {./${this.settings.latexImagesDirectoryName}/} }
% \\cestina % implicitn\xED
% \\slovencina
% \\english
\\pismo{Bookman} % nic (=LModern), Academica, Baskerville, Bookman, Cambria, Comenia, Constantia, Palatino, Times
% \\dvafonty % implicitn\u011B je \\jedenfont
% \\technika
% \\beletrie % implicitn\xED
\\popiskyzkr
% \\popisky % implicitn\xED 
\\pagestyle{headings} % implicitn\xED

\\cislovat{2}
% \\bakalarska % implicitn\xED
% \\diplomova
% \\disertacni
% \\vedecky
${this.thesisType()}

\\brokenpenalty 10000

\\begin{document}

${this.title()}

${this.acknowledgment()}

${this.declaration()}

${this.abstract()}

${this.keywords()}


\\obsah
\\listoffigures
\\listoftables

${body}

${thesisParts.literature && citations ? `\\begin{literatura}
${citations}
\\end{literatura}` : ""}

${thesisParts.attachments && attachments ? `\\prilohy
${attachments}` : ""}

\\end{document}
`;
  }
  parseMetadata(note) {
    const rows = note.split("\n");
    let noteAttrs = {};
    rows.forEach((row) => {
      const [key, value] = row.split(":");
      if (value)
        noteAttrs[key] = value.trim();
    });
    const noteKeys = Object.keys(noteAttrs);
    if (!noteKeys.length) {
      this.metadata = null;
      return;
    }
    this.metadataParams.forEach((key) => {
      this.metadata = {
        ...this.metadata,
        [key]: noteKeys.includes(key) ? noteAttrs[key] : ""
      };
    });
  }
  getMetadata() {
    return this.metadata;
  }
  thesisType() {
    var _a;
    if (!((_a = this.metadata) == null ? void 0 : _a.thesis) || !this.thesisParts.metadata)
      return `\\diplomova`;
    const { thesis } = this.metadata;
    if (thesis === "bachelor")
      return `\\bakalarska`;
    if (thesis === "master")
      return `\\diplomova`;
    if (thesis === "dissertation")
      return `\\disertacni`;
    if (thesis === "scientific")
      return `\\vedecky`;
    return `\\diplomova`;
  }
  title() {
    if (!this.metadata || !Object.keys(this.metadata).length || !this.thesisParts.metadata) {
      return "\\titul{}{}{}{}\n";
    }
    const { title, author, supervisor, locationAndDate } = this.metadata;
    return `\\titul{${title}}{${author}}{${supervisor}}{${locationAndDate}}
`;
  }
  acknowledgment() {
    if (!this.metadata || !Object.keys(this.metadata).length || !this.thesisParts.metadata) {
      return "\\podekovani{}\n";
    }
    return `\\podekovani{${this.metadata.acknowledgment}}
`;
  }
  declaration() {
    if (!this.metadata || !Object.keys(this.metadata).length || !this.thesisParts.metadata) {
      return `\\prohlasenimuz{} \\today}
`;
    }
    return `\\prohlasenimuz{${this.metadata.declaration} \\today}
`;
  }
  abstract() {
    if (!this.metadata || !Object.keys(this.metadata).length || !this.thesisParts.metadata) {
      return `\\abstract{}
{}

\\abstrakt{}
{}
`;
    }
    return `\\abstract{${this.metadata["abstract-title-en"]}}
{${this.metadata["abstract-desc-en"]}}

\\abstrakt{${this.metadata["abstract-title-cs"]}}
{${this.metadata["abstract-desc-cs"]}}
`;
  }
  keywords() {
    if (!this.metadata || !Object.keys(this.metadata).length || !this.thesisParts.metadata) {
      return `\\klslova{}
\\keywords{}
`;
    }
    return `\\klslova{${this.metadata["keywords-cs"]}}
\\keywords{${this.metadata["keywords-en"]}}
`;
  }
  getThesis() {
    return this.thesis;
  }
  getLatexStyle() {
    return latex_style_default;
  }
};

// src/views/citation.ts
var Citation = class {
  constructor(label, settings) {
    this.label = label;
    this.settings = settings;
  }
  parseRow(mark, rows, value = ">") {
    if (rows.length <= 0)
      return "";
    const row = rows.shift().replace(value, "").trim();
    if (row.startsWith("#")) {
      throw new Error("Error parsing citations.");
    }
    if (row === "-")
      return "";
    return row;
  }
};

// src/components/Button.ts
var Button = class {
  constructor(element2, text3, onClick, args) {
    this.btn = element2.createEl("button", { text: text3, ...args });
    this.btn.onclick = () => {
      onClick(this);
    };
    return this;
  }
};

// src/components/Link.ts
var BaseLink = class {
  constructor(context, element2, name) {
    this.context = context;
    this.element = element2;
    this.name = name;
    this.render();
  }
  render() {
    const hrefTitle = this.element.createEl("a", { text: this.name, cls: "title" });
    hrefTitle.onclick = () => {
      this.context.workspace.openLinkText(this.name, "");
    };
  }
};
var Link = class {
  constructor(context, element2, link, renderNow = true) {
    this.toggledState = false;
    this.link = link;
    this.context = context;
    this.element = element2;
    if (renderNow)
      this.render(false);
    return this;
  }
  render(state) {
    this.a = this.element.createEl("a", { text: this.link.name, cls: "link" });
    if (!this.link.exists) {
      this.a.createEl("span", {
        cls: "tooltip-container",
        text: "Warning: Note doesn't exist."
      });
      this.a.addClass("link-not-exist");
      this.a.createEl("i", { cls: "not-found-icon" }).appendChild(new ErrorIcon("#624e9f").element);
      this.a.addClass("tooltip-parent");
    } else if (this.link.incomplete) {
      this.a.createEl("span", {
        cls: "tooltip-container",
        text: "Warning: Note is incomplete."
      });
      this.a.addClass("link-incomplete");
      this.a.createEl("i", { cls: "warning-icon" }).appendChild(new WarningIcon().element);
      this.a.addClass("tooltip-parent");
    }
    this.link.inline && this.a.addClass("inline");
    this.a.onclick = () => {
      this.context.workspace.openLinkText(this.link.path, "");
      !this.link.exists && this.a.removeClass("link-not-exist");
    };
    this.toggle(state);
  }
  toggle(state) {
    if (state)
      this.a.removeClass("strikethrough");
    else
      this.a.addClass("strikethrough");
  }
};

// src/components/SaveModal.ts
var import_obsidian2 = require("obsidian");
var SaveModal = class extends import_obsidian2.Modal {
  constructor(app2, onSubmit, displayToggle = true) {
    super(app2);
    this.isDisabled = true;
    this.displayToggle = true;
    this.onSubmit = onSubmit;
    this.displayToggle = displayToggle;
  }
  getFolders() {
    const folders = this.app.vault.getAllLoadedFiles().filter((file) => file instanceof import_obsidian2.TFolder);
    return folders.reduce((obj, item) => (obj[item.path] = item.path, obj), {});
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Save as" });
    const folders = this.getFolders();
    new import_obsidian2.Setting(contentEl).setName("File name: ").addText((text3) => text3.onChange((value) => {
      this.name = value;
    }));
    if (this.displayToggle) {
      new import_obsidian2.Setting(contentEl).setName("Select folder: ").addDropdown((dropdown) => dropdown.addOptions(folders).onChange((value) => {
        this.folder = value;
      }));
    }
    new import_obsidian2.Setting(contentEl).addButton((btn) => btn.setButtonText("Generate").setCta().onClick(() => {
      var _a;
      this.close();
      this.folder = (_a = this.folder) != null ? _a : this.app.vault.getRoot().path;
      this.onSubmit((0, import_obsidian2.normalizePath)(`${this.folder}/${this.name}.md`));
    }));
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};

// src/components/TreeMenu.ts
function flattenChildren(link, children) {
  if ("children" in link) {
    const childrenLinkNames = link.children.map((l) => l.name);
    children.push(...childrenLinkNames);
    link.children.forEach((l) => {
      flattenChildren(l, children);
    });
  }
  return children;
}
var TreeMenu = class {
  constructor(app2, structure, linksTree, event) {
    this.ignoredLinks = [];
    this.linksTree = [];
    this.app = app2;
    let menu = structure.createEl("div", { cls: "tree-menu" });
    this.UL = menu.createEl("ul");
    this.linksTree = linksTree;
    this.render(this.linksTree, this.UL, [], event);
  }
  render(links, menuEl, childrenLinks, event) {
    if (!childrenLinks)
      childrenLinks = [];
    links.forEach((link) => {
      const li = menuEl.createEl("li");
      const linkEl = new Link(this.app, li, link, false);
      let state = !childrenLinks.includes(linkEl.link.name);
      if (!link.exists)
        state = false;
      new Checkbox(li, state, link.exists, () => {
        const ignoredChildren = [linkEl.link.name, ...flattenChildren(linkEl.link, [])];
        if (state == false) {
          childrenLinks = childrenLinks.filter((cl) => !ignoredChildren.includes(cl));
        } else {
          childrenLinks.push(...ignoredChildren);
          childrenLinks = [...new Set(childrenLinks)];
        }
        this.ignoredLinks = childrenLinks;
        this.UL.empty();
        this.render(this.linksTree, this.UL, childrenLinks, event);
      });
      linkEl.render(state);
      if ("children" in link) {
        const ul = li.createEl("ul");
        this.render(link.children, ul, childrenLinks, event);
      }
    });
    return event(this.ignoredLinks);
  }
};

// src/components/Checkbox.ts
var Checkbox = class {
  constructor(element2, state, exists, onClick) {
    this.cb = element2.createEl("input", {
      type: "checkbox",
      cls: "checkbox-btn"
    });
    this.cb.checked = state;
    if (!exists) {
      this.cb.disabled = true;
      this.cb.checked = false;
      this.cb.addClass("checkbox-btn-disabled");
    }
    this.cb.onclick = () => {
      onClick(this);
    };
    return this;
  }
};

// src/components/SlidesModal.ts
var import_obsidian3 = require("obsidian");
var SlidesModal = class extends import_obsidian3.Modal {
  constructor(app2, links, ignoredLinks, onSubmit) {
    super(app2);
    this.flattenedLinks = [];
    this.maxDepth = 1;
    this.titleSlide = false;
    this.lastSlide = false;
    this.links = links;
    this.ignoredLinks = ignoredLinks;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h1", { text: "Slideshow" });
    this.flattenLinks(this.links);
    const settingsEl = contentEl.createEl("div");
    const depthStr = (depth) => `Slides depth: ${depth}`;
    this.depth = this.maxDepth;
    contentEl.createEl("div", { text: "Include: " });
    const titleSlideEl = contentEl.createEl("div");
    new Checkbox(titleSlideEl, this.titleSlide, true, () => {
      this.titleSlide = !this.titleSlide;
      this.render();
    });
    titleSlideEl.createEl("span", { text: "title slide" });
    const lastSlideEl = contentEl.createEl("div");
    new Checkbox(lastSlideEl, this.lastSlide, true, () => {
      this.lastSlide = !this.lastSlide;
      this.render();
    });
    lastSlideEl.createEl("span", { text: "last slide" });
    this.linksEl = contentEl.createEl("div");
    new import_obsidian3.Setting(settingsEl).setName(depthStr(this.maxDepth)).setDesc("Set depth of preview content to create slides from.").addSlider((slider) => slider.setValue(this.maxDepth).setLimits(1, this.maxDepth, 1).onChange(async (value) => {
      const depthEl = settingsEl.children[0].children[0].children[0];
      depthEl.empty();
      depthEl.createEl("div", { text: depthStr(value) });
      this.depth = value;
      slider.showTooltip();
      this.render();
    }));
    this.render();
    new import_obsidian3.ButtonComponent(contentEl).setButtonText("Generate").onClick(() => {
      this.onSubmit(this.slides, this.titleSlide, this.lastSlide);
      this.close();
    });
  }
  flattenLinks(links) {
    links.forEach((link) => {
      if (this.ignoredLinks.includes(link.name))
        return;
      if (link.level && this.maxDepth <= link.level)
        this.maxDepth = link.level;
      this.flattenedLinks.push(link);
      if ("children" in link && link.level) {
        this.flattenLinks(link.children);
      }
    });
  }
  render() {
    this.linksEl.empty();
    const depthLinks = this.flattenedLinks.filter((link) => link.level && link.level <= this.depth).filter((link) => link.exists);
    this.slides = depthLinks.map((link) => ({ link, type: "basic" }));
    if (this.titleSlide) {
      const slide = this.linksEl.createEl("div", { cls: "slide-row" });
      slide.createEl("span", { text: "1. Title slide" });
      const dropdownEl = slide.createEl("span", { cls: "row-right" });
      new import_obsidian3.DropdownComponent(dropdownEl).setDisabled(true).addOption("title", "title");
    }
    depthLinks.forEach((link) => {
      const slide = this.linksEl.createEl("div", { cls: "slide-row" });
      slide.createEl("span", { text: `${link.level}: ${link.name}` });
      const dropdownEl = slide.createEl("span", { cls: "row-right" });
      new import_obsidian3.DropdownComponent(dropdownEl).addOption("basic", "basic").addOption("split", "split").addOption("image", "image").onChange((value) => {
        const index2 = this.slides.findIndex(({ link: slideLink }) => slideLink.name === link.name);
        this.slides[index2]["type"] = value;
      });
    });
    if (this.lastSlide) {
      const slide = this.linksEl.createEl("div", { cls: "slide-row" });
      slide.createEl("span", { text: "1. Last slide" });
      const dropdownEl = slide.createEl("span", { cls: "row-right" });
      new import_obsidian3.DropdownComponent(dropdownEl).setDisabled(true).addOption("last", "last");
    }
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};

// node_modules/lucide/dist/esm/createElement.js
var createElement = (tag, attrs, children = []) => {
  const element2 = document.createElementNS("http://www.w3.org/2000/svg", tag);
  Object.keys(attrs).forEach((name) => {
    element2.setAttribute(name, String(attrs[name]));
  });
  if (children.length) {
    children.forEach((child) => {
      const childElement = createElement(...child);
      element2.appendChild(childElement);
    });
  }
  return element2;
};
var createElement$1 = ([tag, attrs, children]) => createElement(tag, attrs, children);

// node_modules/lucide/dist/esm/defaultAttributes.js
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};

// node_modules/lucide/dist/esm/icons/alert-triangle.js
var AlertTriangle = [
  "svg",
  defaultAttributes,
  [
    ["path", { d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z" }],
    ["path", { d: "M12 9v4" }],
    ["path", { d: "M12 17h.01" }]
  ]
];

// node_modules/lucide/dist/esm/icons/x-circle.js
var XCircle = [
  "svg",
  defaultAttributes,
  [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "m15 9-6 6" }],
    ["path", { d: "m9 9 6 6" }]
  ]
];

// src/components/Icon.ts
var Icon = class {
  constructor(icon, color = "#333") {
    this.element = createElement$1(icon);
    this.element.setAttribute("stroke", color);
    return this;
  }
};
var ErrorIcon = class {
  constructor(color = "#c70c0f") {
    this.element = new Icon(XCircle, color).element;
    return this;
  }
};
var WarningIcon = class {
  constructor(color = "#8c6f20") {
    this.element = new Icon(AlertTriangle, color).element;
    return this;
  }
};

// src/components/Collapsible.ts
var CollapsibleCitation = class {
  constructor(element2, content3, state) {
    this.stateClasses = {
      visible: "expandable-section-visible",
      hidden: "expandable-section-hidden"
    };
    this.link = element2.createEl("a", { text: state ? "Show less" : "Show more" });
    this.link.onclick = () => {
      this.link.innerText = this.link.innerText === "Show more" ? "Show less" : "Show more";
      this.expandable.classList.toggle(this.stateClasses.visible);
      this.expandable.classList.toggle(this.stateClasses.hidden);
    };
    this.expandable = element2.createEl("div", {
      cls: state ? this.stateClasses.visible : this.stateClasses.hidden
    });
    const table = this.expandable.createEl("table");
    Object.keys(content3).forEach((key) => {
      const tr = table.createEl("tr");
      if (Array.isArray(content3[key])) {
        const arr = content3[key];
        arr.forEach((item) => {
          const subTr = table.createEl("tr");
          subTr.createEl("th", { text: key }).setAttr("align", "left");
          subTr.createEl("td", { text: item || "\u2013\u2060\u2060\u2060\u2060\u2060\u2060\u2060\u2060\u2060" });
        });
      } else {
        tr.createEl("th", { text: key }).setAttr("align", "left");
        tr.createEl("td", { text: content3[key] || "\u2013\u2060\u2060\u2060\u2060\u2060\u2060\u2060\u2060\u2060" });
      }
    });
    return this;
  }
};

// src/views/generate-latex.ts
var GenerateLatex = class {
  constructor(app2, settings, structure) {
    this.citations = [];
    this.images = [];
    this.errors = [];
    this.imageRefRegex = new RegExp(/\[(.*(.jpg|.gif|.png|.bmp|.webp))\]/g);
    this.latex = "";
    this.settings = settings;
    this.app = app2;
    this.structure = structure;
    const activeNote = app2.workspace.getActiveFile();
    if (!activeNote) {
      new import_obsidian4.Notice(`Selected note is invalid.`);
      throw new Error("Selected note is invalid.");
    }
    this.activeNote = activeNote;
  }
  async loadRequirements(isPlain = false) {
    var _a;
    this.images = [];
    this.activeNoteText = await this.getActiveNote(this.app, this.activeNote);
    this.allFiles = app.vault.getAllLoadedFiles();
    let images = this.getImages(this.activeNoteText, this.allFiles);
    let metadata = null;
    if (!isPlain) {
      this.literatureNote = await this.getLiteratureNote(this.app, this.settings.literatureNote);
      this.literature = this.parseLiteratureNote(this.literatureNote);
      this.attachments = await this.getAttachments(this.app, this.allFiles);
      const metadataNote = await this.getTemplateMetadataNote(this.app, `${this.settings.metadataNote}.md`);
      this.template = new PEFTemplate(metadataNote, this.settings);
      metadata = this.template.getMetadata();
      if ((_a = this.attachments) == null ? void 0 : _a.images) {
        const { correct, incorrect, count } = this.attachments.images;
        images = {
          ...images,
          correct: [...images.correct, ...correct],
          incorrect: [...images.incorrect, ...incorrect],
          count: images.count + count
        };
      }
    }
    return {
      metadata,
      attachments: this.attachments,
      literature: this.literature,
      images
    };
  }
  async renderLatexStatus(generateLatex) {
    this.structure.empty();
    new BaseLink(this.app, this.structure, generateLatex.activeNote.basename);
    const { images } = await generateLatex.loadRequirements(true);
    this.imageLatexStatus(images);
    new Button(this.structure, "Generate LaTeX", () => {
      generateLatex.generate(images);
    }, { cls: "generate-final-btn" });
  }
  async renderLatexWithTemplateStatus(generateLatex) {
    const insertThesisParts = {
      metadata: true,
      literature: true,
      attachments: true
    };
    const insertWithCheckbox = (structure, type, onClick) => {
      const settingPaths = {
        attachment: this.settings.attachmentsDir,
        literature: this.settings.literatureNote,
        metadata: this.settings.metadataNote
      };
      let state = true;
      const insertAttEl = structure.createEl("div", { cls: "insert-with-checkbox" });
      insertAttEl.createEl("span", {
        text: `Insert ${type} (${settingPaths[type]}.md)`
      });
      new Checkbox(insertAttEl, state, true, () => {
        state = !state;
        onClick(state);
        insertThesisParts[type] = state;
      });
    };
    const applyStateClass = (element2, state, className = "disabled-text") => {
      if (state)
        element2.addClass(className);
      else
        element2.removeClass(className);
    };
    new BaseLink(this.app, this.structure, generateLatex.activeNote.basename);
    const {
      metadata,
      attachments,
      literature,
      images
    } = await generateLatex.loadRequirements();
    this.structure.createEl("h3", {
      text: "Metadata" + (metadata ? ` (${Object.keys(metadata).length})` : "")
    });
    if (metadata) {
      let table;
      insertWithCheckbox(this.structure, "metadata", (state) => {
        applyStateClass(table, !state);
      });
      table = this.structure.createEl("table");
      Object.keys(metadata).forEach((key) => {
        const tr = table.createEl("tr");
        tr.createEl("th", { text: key }).setAttr("align", "left");
        tr.createEl("td", { text: metadata[key] || "\u2013\u2060\u2060\u2060\u2060\u2060\u2060\u2060\u2060\u2060" });
      });
    } else {
      this.structure.createEl("div", { text: "Metadata not loaded." });
    }
    this.imageLatexStatus(images);
    this.structure.createEl("h3", {
      text: "Literature" + (literature.citations.length ? ` (${literature.citations.length})` : "")
    });
    if (this.literatureNote) {
      let contentEl;
      if (literature.citations.length) {
        insertWithCheckbox(this.structure, "literature", (state) => {
          applyStateClass(contentEl, !state);
        });
        contentEl = this.structure.createEl("div");
        literature.citations.forEach((lit) => {
          const litEl = contentEl.createEl("div", { cls: "row-spacy" });
          const labelEl = litEl.createEl("a", { text: lit.label, cls: "bold" });
          labelEl.onclick = () => {
            const literatureLinkPath = `${this.settings.literatureNote}#${lit.label}`;
            this.app.workspace.openLinkText(literatureLinkPath, "");
          };
          litEl.createEl("div", { text: lit.title });
          new CollapsibleCitation(litEl, lit, false);
        });
      }
      if (literature.incorrect.length > 0) {
        contentEl = this.structure.createEl("div");
        contentEl.createEl("strong", { text: "Incorrect citations" });
        literature.incorrect.forEach((label) => {
          const litEl = contentEl.createEl("div", { cls: "row-spacy" });
          litEl.createEl("i", { cls: "error-icon" }).appendChild(new ErrorIcon().element);
          const labelEl = litEl.createEl("a", { text: label, cls: "bold" });
          labelEl.onclick = () => {
            const literatureLinkPath = `${this.settings.literatureNote}#${label}`;
            this.app.workspace.openLinkText(literatureLinkPath, "");
          };
        });
      }
    } else {
      this.structure.createEl("div", { text: "Literature not loaded." });
    }
    this.structure.createEl("h3", {
      text: "Attachments" + (attachments ? ` (${attachments == null ? void 0 : attachments.attachments.length})` : "")
    });
    if (attachments) {
      let contentEl;
      insertWithCheckbox(this.structure, "attachment", (state) => {
        applyStateClass(contentEl, !state);
      });
      const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      contentEl = this.structure.createEl("div");
      attachments.attachments.forEach((attachment, key) => {
        const attEl = contentEl.createEl("div", { cls: "row-spacy" });
        attEl.createEl("div", { text: `Attachment ${alphabet[key] || "-"}`, cls: "bold" });
        attEl.createEl("a", { text: attachment.basename, cls: "bold" });
        attEl.onclick = () => {
          this.app.workspace.openLinkText(attachment.path, "");
        };
        attEl.createEl("span", { text: ` - ${attachment.path}` });
      });
    } else {
      this.structure.createEl("div", { text: "Attachments not loaded." });
    }
    new Button(this.structure, "Generate LaTeX", () => {
      generateLatex.generate(images, insertThesisParts);
    }, { cls: "generate-final-btn" });
  }
  imageLatexStatus({
    correct,
    incorrect,
    count
  }) {
    this.structure.createEl("h3", {
      text: "Images" + (!!count ? ` (${count})` : "")
    });
    if (!!count) {
      correct.forEach((image) => {
        const imgEl = this.structure.createEl("div", { cls: "row-spacy" });
        const a = imgEl.createEl("a", { text: image.name, cls: "bold" });
        a.onclick = () => {
          this.app.workspace.openLinkText(image.path, "");
        };
        imgEl.createEl("div", { text: image.desc });
        image.source && imgEl.createEl("div", { text: image.source });
      });
      if (incorrect.length > 0) {
        this.structure.createEl("strong", { text: "Incorrect images (bad format)" });
        incorrect.forEach((image) => {
          const imgEl = this.structure.createEl("div", { cls: "row-spacy" });
          imgEl.createEl("i", { cls: "error-icon" }).appendChild(new ErrorIcon().element);
          const a = imgEl.createEl("a", { text: image.name, cls: "bold" });
          a.onclick = () => {
            this.app.workspace.openLinkText(image.path, "");
          };
        });
      }
    } else {
      this.structure.createEl("div", { text: "No images found." });
    }
  }
  generate(images, thesisParts) {
    var _a;
    const latex = this.translateMarkdown(this.activeNoteText);
    if (images.incorrect.length > 0) {
      new import_obsidian4.Notice(`Fix images format before generating Latex.`);
      throw new Error("Fix images format before generating Latex.");
    }
    if (!thesisParts) {
      this.generateLatexFiles(latex);
    } else {
      const latexCitations = this.createLatexCitations(this.literature.citations);
      const latexAttachments = this.attachments ? (_a = this.attachments) == null ? void 0 : _a.latex : null;
      const thesis = this.template.composeThesis(thesisParts, latex, latexCitations, latexAttachments);
      this.generateLatexFiles(thesis, false);
    }
  }
  translateMarkdown(note) {
    const root = fromMarkdown(note);
    let latex = root.children.map((child) => {
      const result = this.node(child, 0);
      if (result && result.startsWith("#"))
        return;
      return result;
    }).join("\n\n");
    latex = this.refCite(latex);
    latex = this.mergeCloseRefCitations(latex);
    latex = this.refImage(latex);
    latex = this.removeMarkdownLeftovers(latex);
    latex = this.basicRef(latex);
    latex = this.fixLatexSpecialCharacters(latex);
    return latex;
  }
  generateLatexFiles(thesis, isPlain = true) {
    new SaveModal(app, async (path) => {
      const basePath = app.vault.adapter.basePath;
      const vaultPath = Path.join(basePath, "generated-latex");
      if (!fs.existsSync(vaultPath))
        fs.mkdirSync(vaultPath);
      const thesisName = path.replace(".md", "");
      const thesisDir = Path.join(vaultPath, thesisName + "_" + formatDateNow());
      fs.mkdirSync(thesisDir);
      const imageDirName = this.settings.latexImagesDirectoryName;
      const imageDirPath = Path.join(thesisDir, imageDirName);
      fs.mkdirSync(imageDirPath);
      const images = [];
      this.images.forEach((img) => {
        const imageObject = this.allFiles.find((file) => file.name.toLowerCase() === img.url.toLowerCase());
        if (imageObject)
          images.push(imageObject);
      });
      images.forEach((image) => {
        const oldPath = Path.join(basePath, image.path);
        const newPath = Path.join(imageDirPath, image.name.toLowerCase());
        fs.copyFileSync(oldPath, newPath);
      });
      fs.writeFileSync(Path.join(thesisDir, "main.tex"), thesis);
      if (!isPlain) {
        const latexTemplate = this.template.getLatexStyle();
        fs.writeFileSync(Path.join(thesisDir, "latexStyle.sty"), latexTemplate);
      }
      new import_obsidian4.Notice(`${thesisName} and ${imageDirName} created successfully.`);
      new import_obsidian4.Notice(`${images.length} images copied successfully.`);
    }, false).open();
  }
  heading(ast) {
    const { depth, children } = ast;
    const transformHeadings = {
      1: "kapitola",
      2: "sekce",
      3: "podsekce"
    };
    let heading = null;
    const headingValue = children[0].value;
    if (depth >= 1 && depth <= 3) {
      const level = transformHeadings[depth];
      heading = `\\${level}{${headingValue}}`;
    } else {
      heading = `\\subsubsection*{${headingValue}}`;
    }
    return heading;
  }
  node(ast, indent = 0) {
    if ("value" in ast) {
      if (ast.type == "text" && ast.value.split("|").length >= 5) {
        return this.table(ast.value);
      }
      if (ast.type == "code") {
        return this.code(ast);
      }
      if (ast.type == "inlineCode") {
        return this.inlineCode(ast);
      }
      return ast.value;
    }
    if (ast.type == "heading") {
      return this.heading(ast);
    }
    if (ast.type == "list") {
      if (ast.ordered) {
        return "	".repeat(indent) + "\\begin{enumerate}\n" + ast.children.map((sub) => this.node(sub, indent + 1)).join("\n") + "\n" + "	".repeat(indent) + "\\end{enumerate}\n";
      } else {
        return "\\begin{itemize}\n" + ast.children.map((sub) => this.node(sub, indent + 1)).join("\n") + "\n\\end{itemize}\n";
      }
    }
    if (ast.type == "image") {
      return `\\obrazek
\\vlozobrbox{${ast.url}}{0.7\\textwidth}{!}
\\endobrl{${(ast == null ? void 0 : ast.alt) ? `${this.fixLatexSpecialCharacters(ast == null ? void 0 : ast.alt)}` : ""}${(ast == null ? void 0 : ast.title) ? ` \\obrzdroj{${this.fixLatexSpecialCharacters(ast.title)}}` : ""}}
{${ast.url}}`;
    }
    try {
      return ast.children.map((child) => {
        if (ast.type == "paragraph") {
          return this.node(child);
        }
        if (ast.type == "strong") {
          return "\\textbf{" + this.node(child) + "}";
        }
        if (ast.type == "emphasis") {
          return "{\\it " + this.node(child) + "}";
        }
        if (ast.type == "listItem") {
          if (child.type == "list")
            return "\n" + this.node(child, indent);
          return "	".repeat(indent) + "\\item " + this.node(child, indent);
        }
      }).join("");
    } catch (error) {
      this.errors.push({
        type: "unknown_markdown",
        item: [ast.type],
        message: `Markdown translation error: ${ast.type}.`
      });
      console.error(this.errors);
    }
  }
  refCite(latex) {
    const links = [...latex.matchAll(/\[\[.+#(\w+)\]\]/g)];
    links.forEach(([raw, clean]) => {
      latex = latex.replace(raw, `\\cite{${clean.toLowerCase()}}`);
    });
    return latex;
  }
  parseLiteratureNote(note) {
    const notesRow = note.split("\n");
    const allCitations = notesRow.filter((row) => row.startsWith("#")).map((row) => row.replace("#", "").trim());
    const citations = [];
    while (notesRow.length > 0) {
      const row = notesRow.shift();
      if (row === "")
        continue;
      if (row.startsWith("#")) {
        let citation, type, inline, authors, title;
        const label = row.replace("#", "").trim();
        try {
          citation = new Citation(label, this.settings);
          type = citation.parseRow("type", notesRow);
          inline = citation.parseRow("citation in text", notesRow);
          authors = [];
          while (notesRow[0].startsWith("-")) {
            authors.push(citation.parseRow("author", notesRow, "-"));
          }
          title = citation.parseRow("title", notesRow);
        } catch (e) {
          console.error(e);
          continue;
        }
        const commonParams = {
          label,
          type,
          inline,
          authors,
          title
        };
        if (type.toLowerCase() === "book") {
          const citationBlock = { ...commonParams };
          try {
            citationBlock["format"] = citation.parseRow("format", notesRow);
            citationBlock["publishedPlace"] = citation.parseRow("published place", notesRow);
            citationBlock["publisher"] = citation.parseRow("publisher", notesRow);
            citationBlock["publishedYear"] = citation.parseRow("published year", notesRow);
            citationBlock["edition"] = citation.parseRow("edition", notesRow);
            citationBlock["isbn"] = citation.parseRow("isbn", notesRow);
            citationBlock["date"] = citation.parseRow("date", notesRow);
            citationBlock["source"] = citation.parseRow("source", notesRow);
            citations.push({ ...commonParams, ...citationBlock });
          } catch (e) {
            console.error(e);
            continue;
          }
        } else if (type.toLocaleLowerCase() === "web") {
          const citationBlock = { ...commonParams };
          try {
            citationBlock["webDomain"] = citation.parseRow("web domain", notesRow);
            citationBlock["publishedPlace"] = citation.parseRow("published place", notesRow);
            citationBlock["publisher"] = citation.parseRow("publisher", notesRow);
            citationBlock["publishedDate"] = citation.parseRow("published date", notesRow);
            citationBlock["revisionDate"] = citation.parseRow("revision date", notesRow);
            citationBlock["date"] = citation.parseRow("date", notesRow);
            citationBlock["source"] = citation.parseRow("source", notesRow);
            citations.push(citationBlock);
          } catch (e) {
            console.error(e);
            continue;
          }
        } else {
          console.error("Incorrect/missing type");
          continue;
        }
      }
    }
    const correctLabels = citations.map((citation) => citation.label);
    const incorrectCitations = allCitations.filter((citation) => !correctLabels.includes(citation));
    return {
      citations,
      incorrect: incorrectCitations
    };
  }
  createLatexCitations(citations) {
    citations = citations.sort((a, b) => a.label.localeCompare(b.label));
    const citationString = citations.map((citation) => {
      if (citation.type.toLowerCase() === "book") {
        const {
          label,
          inline,
          title,
          format,
          edition,
          isbn,
          publishedYear,
          date,
          source,
          publishedPlace,
          publisher,
          authors
        } = citation;
        return `\\citace{${label.toLowerCase()}}{${inline}}{
\\autor{${authors.join(", ")}}
\\nazev{${title && `${title}.`}}${format && ` [${format}].`}${publishedPlace && ` ${publishedPlace}:`}${publisher && ` ${publisher},`}${publishedYear && ` ${publishedYear}.`}${edition && ` ${edition}.`}${isbn && ` ${isbn}.`} [${date}].${source && ` Dostupn\xE9 z: ${this.fixLatexSpecialCharacters(source)}`}}`;
      } else if (citation.type.toLowerCase() === "web") {
        const {
          label,
          inline,
          title,
          revisionDate,
          publishedDate,
          webDomain,
          date,
          source,
          publishedPlace,
          publisher,
          authors
        } = citation;
        return `\\citace{${label.toLowerCase()}}{${inline}}{
\\autor{${authors.join(",")}}
\\nazev{${title && `${title}.`}${webDomain && ` ${webDomain}`}} [online].${publishedPlace && ` ${publishedPlace}:`}${publisher && ` ${publisher},`}${publishedDate && ` ${publishedDate},`}${revisionDate && ` ${revisionDate}`} [${date}].${source && ` Dostupn\xE9 z: ${this.fixLatexSpecialCharacters(source)}`}}`;
      }
    }).join("\n\n");
    return citationString;
  }
  refImage(latex) {
    const refs = [...latex.matchAll(this.imageRefRegex)];
    refs.forEach(([raw, clean]) => {
      const [match] = this.images.filter((img) => img.url === clean);
      if (match) {
        latex = latex.replace(raw, `\\ref{${clean}}`);
      } else {
        this.errors.push({ type: "ref_image", item: [raw, clean], message: `Reference to image '${clean}' ('${raw}') is not valid.` });
        console.error(this.errors);
      }
    });
    return latex;
  }
  mergeCloseRefCitations(latex) {
    const regexes = [
      new RegExp(/((\\cite{\w+}\s*){5})/g),
      new RegExp(/((\\cite{\w+}\s*){4})/g),
      new RegExp(/((\\cite{\w+}\s*){3})/g),
      new RegExp(/((\\cite{\w+}\s*){2})/g)
    ];
    regexes.forEach((regex) => {
      const refs = [...latex.matchAll(regex)];
      refs.forEach((ref) => {
        const matches = [...ref[0].matchAll(/\\cite{(\w+)}/g)];
        const cleanRefs = matches.map((m) => m[1]).join(",");
        latex = latex.replace(ref[0], `\\cite{${cleanRefs}}`);
      });
    });
    return latex;
  }
  table(markdownTable) {
    const mRows = markdownTable.split("\n");
    const mHeader = mRows.shift();
    mRows == null ? void 0 : mRows.shift();
    const tHeader = mHeader == null ? void 0 : mHeader.split("|").filter(Boolean).map((h) => h.trim());
    let tBody = null;
    let metadata = null;
    if (mRows.length >= 1) {
      const match = [...mRows[mRows.length - 1].matchAll(/\[(.*?)\]/g)];
      metadata = { label: null, cite: null, source: null };
      const headerMetadata = ["label", "cite", "source"];
      if (match.length > 0) {
        mRows.pop();
        metadata = headerMetadata.reduce((acc, cur, i) => {
          return {
            ...acc,
            [cur]: match.length >= i + 1 ? match[i][1] : null
          };
        }, {});
      }
      tBody = mRows == null ? void 0 : mRows.map((mRow) => {
        const cols = mRow.split("|").filter(Boolean).map((h) => h.trim());
        return tHeader == null ? void 0 : tHeader.reduce((acc, cur, i) => ({ ...acc, [cur]: cols[i] }), {});
      });
    }
    let latexTable = `\\tabulka{${(metadata == null ? void 0 : metadata.cite) ? metadata.cite : ""}}
\\label{${(metadata == null ? void 0 : metadata.label) ? metadata.label : ""}}
\\def\\arraystretch{1.5}
\\begin{tabular}{|l|c|c|} \\hline
` + (tHeader == null ? void 0 : tHeader.map((h, i) => `\\textbf{${h}} ` + (tHeader.length - 1 != i ? "&" : `\\\\ \\hline`)).join("\n"));
    if (tBody) {
      latexTable += "\n";
      latexTable += tBody.map((row) => {
        return Object.values(row).map((col, i) => `${col} ` + (Object.values(row).length - 1 != i ? "&" : `\\\\ \\hline`)).join(" ");
      }).join("\n");
    }
    latexTable += `
\\end{tabular}
`;
    if (metadata == null ? void 0 : metadata.source) {
      latexTable += `
\\tabzdroj{${metadata.source ? metadata.source : ""}}
\\endtab`;
    } else {
      latexTable += "\\endtab";
    }
    return latexTable;
  }
  code(ast) {
    var _a, _b;
    const metadata = {
      label: null,
      cite: null
    };
    if (ast.meta) {
      const metaArr = ast.meta.split("|");
      if (metaArr.length == 1) {
        metadata["label"] = metaArr[0];
      }
      if (metaArr.length == 2) {
        metadata["label"] = metaArr[0];
        metadata["cite"] = metaArr[1];
      }
    }
    return `\\begin{lstlisting}[language=java, caption=${(_a = metadata.cite) != null ? _a : ""}, label={${(_b = metadata.label) != null ? _b : ""}}]
` + ast.value + `
\\end{lstlisting}`;
  }
  inlineCode(ast) {
    return "{\\it " + this.fixLatexSpecialCharacters(ast.value) + "}";
  }
  removeMarkdownLeftovers(latex) {
    const links = [...latex.matchAll(/\[\[(.*)\]\]/g)];
    links.forEach(([raw, clean]) => {
      if (clean.startsWith("#"))
        clean = clean.replace("#", "");
      latex = latex.replaceAll(raw, `${clean}`);
    });
    return latex;
  }
  basicRef(latex) {
    const possibleRefs = [...latex.matchAll(/\[(\w+)\]/g)];
    possibleRefs.forEach(([raw, clean]) => {
      latex = latex.replace(raw, `\\ref{${clean}}`);
    });
    return latex;
  }
  getImages(note, allFiles) {
    const images = [...note.matchAll(/\!\[(.*)\]\((.*)\)/g)];
    const correctImages = [];
    images.forEach(([raw]) => {
      var _a, _b, _c, _d;
      try {
        const root = fromMarkdown(raw).children;
        const image = root[0].children[0];
        if (image.type === "image") {
          correctImages.push({
            raw: image.url,
            desc: (_a = image.alt) != null ? _a : void 0,
            name: image.url,
            source: (_b = image.title) != null ? _b : void 0,
            path: (_d = (_c = allFiles.find((file) => file.name.toLowerCase() === (image == null ? void 0 : image.url.toLowerCase()))) == null ? void 0 : _c.path) != null ? _d : image == null ? void 0 : image.url
          });
          this.images.push(image);
        }
      } catch (e) {
        console.error(`Something went wrong: ${e}`);
      }
    });
    const incorrectImages = [
      ...note.matchAll(/\!\[\[(.*)\]\]/g),
      ...note.matchAll(/\!\[(.*)\]\[(.*)\]/g)
    ];
    const incorrect = incorrectImages.map(([raw, name]) => {
      var _a, _b;
      return {
        raw,
        name,
        path: (_b = (_a = allFiles.find((file) => file.name.toLowerCase() === name.toLowerCase())) == null ? void 0 : _a.path) != null ? _b : name
      };
    });
    return {
      count: correctImages.length + incorrect.length,
      correct: correctImages,
      incorrect
    };
  }
  async getAttachments(app2, allFiles) {
    if (!this.settings.attachmentsDir)
      return null;
    const attachments = allFiles.filter((file) => file.path.includes(this.settings.attachmentsDir) && (file == null ? void 0 : file.extension) === "md").sort((a, b) => a.name.localeCompare(b.name));
    if (attachments.length <= 0)
      return null;
    let attachmentLatex = "";
    let images = {
      correct: [],
      incorrect: [],
      count: 0
    };
    for await (const att of attachments) {
      const note = await getNoteByName(app2, att.path);
      const { correct, incorrect, count } = this.getImages(note, allFiles);
      if (count > 0) {
        images = {
          ...images,
          correct: [...images.correct, ...correct],
          incorrect: [...images.incorrect, ...incorrect],
          count: images.count + count
        };
      }
      const latex = this.translateMarkdown(note);
      attachmentLatex += `
\\priloha{${att.basename}}
${latex}
`;
    }
    return {
      attachments,
      images,
      latex: attachmentLatex
    };
  }
  fixLatexSpecialCharacters(latex) {
    latex = latex.replaceAll("_", "\\_");
    latex = latex.replaceAll("%", "\\%");
    latex = latex.replaceAll("$", "\\$");
    latex = latex.replaceAll("#", "\\#");
    return latex;
  }
  async getActiveNote(app2, activeNote) {
    const text3 = await getNoteByName(app2, activeNote.path);
    if (!activeNote) {
      new import_obsidian4.Notice(`Selected note is invalid.`);
      throw new Error("Selected note is invalid.");
    }
    return text3;
  }
  async getLiteratureNote(app2, path) {
    const literature = await getNoteByName(app2, `${path}.md`);
    return literature;
  }
  async getTemplateMetadataNote(app2, path) {
    const templateNote = await getNoteByName(app2, path);
    return templateNote;
  }
};

// src/views/generate-markdown.ts
var import_obsidian5 = require("obsidian");

// src/views/generate-slides-markdown.ts
var fs2 = __toESM(require("fs"));
var Path2 = __toESM(require("path"));

// src/slideshow-template/default.ts
var tplConTitle = `
<grid drag="100 100" drop="0 0" flow="col" align="bottom">
<% source %>
</grid>

<grid drag="90 10" drop="5 40"  align="centre" pad="0 20px">
<% title %>
</grid>

<% content %>

<style>
.horizontal_dotted_line{
border-bottom: 2px dotted gray;
} 
} 
</style>

<grid drag="94 0" drop="3 -8" class="horizontal_dotted_line">
</grid>`;
var tplConLast = `
<grid drag="100 100" drop="top" >
<% content %>
</grid>

<style>
.horizontal_dotted_line{
  border-bottom: 2px dotted gray;
} 
} 
</style>

<grid drag="94 0" drop="3 -8" class="horizontal_dotted_line">
</grid>`;
var tplConBasic = `
<grid drag="100 10" drop="top" bg="white" align="left" pad="0 20px">
 <% title %>
</grid>

<grid drag="94 70" drop="3 15" bg="white" style="border-radius:15px"/>

<grid drag="90 66" drop="5 17" align="topleft">
<% content %>
</grid>

<style>
.horizontal_dotted_line{
  border-bottom: 2px dotted gray;
} 
} 
</style>

<grid drag="94 0" drop="3 -6" class="horizontal_dotted_line">
</grid>

<grid drag="100 30" drop="0 64" align="bottomleft" pad="0 30px" >
<%? source %>
</grid>`;
var tplConImage = `
<grid drag="100 10" drop="top" bg="white" align="left" pad="0 20px">
 <% title %>
</grid>

<grid drag="90 75" drop="5 12"  align="centre">
<% middle %>
</grid>

<grid drag="90 5" drop="5 -6"  align="centre">
<%? source %>
</grid>

<% content %>

<style>
.horizontal_dotted_line{
  border-bottom: 2px dotted gray;
} 
} 
</style>

<grid drag="94 0" drop="3 -6" class="horizontal_dotted_line">
</grid>`;
var tplConSplit = `
<grid drag="100 10" drop="top" bg="white" align="left" pad="0 20px">
 <% title %>
</grid>

<grid drag="37 75" drop="3 15" bg="white" style="border-radius:15px"/>

<grid drag="35 71" drop="4 17" align="topleft">
<% left %>
</grid>


<grid drag="57 75" drop="41 15" align="centre">
<% right %>
</grid>

<grid drag="54 4" drop="-3 -6"  align="centre">
<%? source %>
</grid>

<% content %>

<style>
.horizontal_dotted_line{
  border-bottom: 2px dotted gray;
} 
} 
</style>

<grid drag="94 0" drop="3 -6" class="horizontal_dotted_line">
</grid>`;

// src/views/generate-slides-markdown.ts
var SlidesMarkdown = class {
  constructor(slides, title, hasTitleSlide, hasLastSlide) {
    this.slides = [];
    this.slideshow = "";
    this.slides = slides;
    this.slideshow += this.createProperties();
    if (hasTitleSlide)
      this.slideshow += this.createTitleSlide(title);
    slides.forEach((slide) => {
      if (slide.type === "basic")
        this.slideshow += this.createBasicSlide(slide.link.name);
      else if (slide.type === "split")
        this.slideshow += this.createSplitSlide(slide.link.name);
      else if (slide.type === "image")
        this.slideshow += this.createImageSlide(slide.link.name);
    });
    if (hasLastSlide)
      this.slideshow += this.createLastSlide();
    return this;
  }
  createProperties() {
    return `---
theme: consult
height: 540
margin: 0
maxScale: 4
---

`;
  }
  createTitleSlide(title) {
    return `
<!-- slide template="[[tpl-title]]" -->

::: title

## _${title}_
:::

::: source

###### add author here
:::

`;
  }
  createLastSlide() {
    return `
---
<!-- slide template="[[tpl-last]]" -->

#### _\u010Eakujem za pozornos\u0165_

`;
  }
  createBasicSlide(name) {
    return `
---
<!-- slide template="[[tpl-basic]]" -->

::: title
### _**${name}**_
:::

::: block
-
-
-
:::<!-- element style="font-size:16px;color:black;font-weight:600;line-height:1.9" pad="20px 0" -->

`;
  }
  createImageSlide(name) {
    return `
---
<!-- slide template="[[tpl-image]]" -->

::: title
### _**${name}**_
:::

::: middle
![[write name of image here|number of pixels]]
:::<!-- element align="center" -->

::: source
###### Write description and source here.
:::

`;
  }
  createSplitSlide(name) {
    return `
---
<!-- slide template="[[tpl-split]]" -->

::: title
### _**${name}**_
:::

::: left
#### **text in left box**
- lorem ipsum
-
-
:::<!-- element style="font-size:14px;color:black;font-weight:500;line-height:1.9" pad="20px 20px" -->

::: right
![[write name of image here|number of pixels]]
:::<!-- element align="center" -->

::: source
###### Write description and source here.
:::

`;
  }
  copyTemplates() {
    const basePath = app.vault.adapter.basePath;
    const vaultPath = Path2.join(basePath, "slideshow-templates");
    if (!fs2.existsSync(vaultPath))
      fs2.mkdirSync(vaultPath);
    const templates = {
      "tpl-title": tplConTitle,
      "tpl-last": tplConLast,
      "tpl-basic": tplConBasic,
      "tpl-image": tplConImage,
      "tpl-split": tplConSplit
    };
    Object.keys(templates).forEach((templateName) => {
      fs2.writeFileSync(Path2.join(vaultPath, `${templateName}.md`), templates[templateName]);
    });
  }
};

// src/views/generate-markdown.ts
var _GenerateMarkdown = class {
  constructor(app2, settings, structure, subbar) {
    this.loadedFiles = [];
    this.mainNameLinks = [];
    this.linksTree = [];
    this.maxLevel = 0;
    this.processed = [];
    this.markdown = "";
    this.ignoredLinks = [];
    this.images = [];
    this.app = app2;
    this.settings = settings;
    this.structure = structure;
    this.subbar = subbar;
    this.linksTree = [];
    this.maxLevel = 0;
    this.processed = [];
    this.mainNameLinks = [];
    this.ignoredLinks = [];
    this.markdown = "";
  }
  async readSelectedNote() {
    this.loadedFiles = this.app.vault.getMarkdownFiles();
    const activeNote = this.app.workspace.getActiveFile();
    if (!activeNote) {
      new import_obsidian5.Notice(`Selected note is invalid.`);
      throw new Error("Selected note is invalid.");
    }
    const activeNoteText = await getNoteByName(this.app, activeNote.path);
    const mainContentLinks = this.parseLinks(activeNoteText, true);
    this.mainNameLinks = mainContentLinks.map((l) => l.name);
    this.linksTree = await this.generateNotesHierarchy(mainContentLinks);
    const title = activeNote.basename;
    new BaseLink(this.app, this.structure, title);
    new TreeMenu(this.app, this.structure, this.linksTree, (ignoredLinks) => {
      this.ignoredLinks = ignoredLinks;
    });
    new Button(this.subbar, "Generate Markdown", () => {
      this.markdown = "";
      this.generateMarkdownFile(this.linksTree, activeNoteText);
    }, { cls: "generate-markdown-btn" });
    new Button(this.subbar, "Generate Slideshow", () => {
      new SlidesModal(this.app, this.linksTree, this.ignoredLinks, (slides, hasTitleSlide, hasLastSlide) => {
        const slidesMD = new SlidesMarkdown(slides, title, hasTitleSlide, hasLastSlide);
        new SaveModal(this.app, async (path) => {
          slidesMD.copyTemplates();
          await this.app.vault.adapter.write(path, slidesMD.slideshow);
          new import_obsidian5.Notice(`Slideshow ${path} created successfully`);
          this.app.workspace.openLinkText(path, "");
        }).open();
      }).open();
    }, { cls: "generate-slides-btn" });
  }
  parseLinks(text3, index2 = false) {
    const links = text3.matchAll(/\[\[(.*?)\]\]/g);
    let cleanLinks = [...links].map((l) => l[1]);
    cleanLinks = [...new Set(cleanLinks)];
    cleanLinks = cleanLinks.filter((cl) => !cl.startsWith("#"));
    cleanLinks = cleanLinks.filter((cl) => !cl.startsWith(`${this.settings.literatureNote}#`));
    const existingNotes = cleanLinks.map((cl) => {
      cl = fixSpaceInName(cl);
      if (!!_GenerateMarkdown.imageTypes.filter((it) => cl.includes(it.toLowerCase())).length) {
        this.images.push(cl);
        return false;
      }
      let isInline = true;
      if (text3.includes(this.settings.listOfLinksKeyword)) {
        let [inlineText, linksText] = text3.split(this.settings.listOfLinksKeyword);
        if (!inlineText.includes(`[[${cl}]]`)) {
          isInline = false;
        }
      }
      let isIndex = false;
      if (index2) {
        isInline = false;
        isIndex = true;
      }
      const note = this.loadedFiles.find((f) => f["basename"] === cl);
      return {
        name: cl,
        exists: !!note,
        inline: isInline,
        index: isIndex,
        path: note == null ? void 0 : note.path
      };
    }).filter(Boolean);
    return existingNotes;
  }
  async generateMarkdownFile(links, mainNote) {
    this.composeMarkdown(links);
    this.markdown = this.markdown.trim();
    if (this.settings.insertIndexNote) {
      this.mainNameLinks.forEach((mnl) => {
        mnl = fixSpaceInName(mnl);
        mainNote = mainNote.replaceAll(`[[${mnl}]]`, `[[#${mnl}]]`);
      });
      this.markdown = mainNote + "\n" + this.markdown;
    }
    if (this.settings.insertPreviewContent) {
      const contentPreview = this.makeContentPreviewMD(links, "");
      this.markdown = contentPreview + "\n" + this.markdown;
    }
    new SaveModal(this.app, async (path) => {
      await this.app.vault.adapter.write(path, this.markdown);
      new import_obsidian5.Notice(`Note ${path} created successfully`);
      this.app.workspace.openLinkText(path, "");
    }).open();
  }
  composeMarkdown(links) {
    const inlineLinks = links.filter((link) => link.inline);
    this.markdown = this.insertToNearestNewLine(this.markdown, inlineLinks);
    inlineLinks.forEach((iLink) => {
      const re = new RegExp(`^\\[\\[#?${iLink.name}\\]\\]
`, "gm");
      this.markdown = this.markdown.replace(re, "");
    });
    links.forEach((link) => {
      if (this.ignoredLinks.includes(link.name))
        return;
      let note = link.note.trim();
      note = this.cleanNote(link, note);
      if (note.includes(this.settings.listOfLinksKeyword)) {
        const [importantPart, endPart] = note.split(this.settings.listOfLinksKeyword);
        note = importantPart.trim();
      }
      const title = this.transformTitle(link);
      note = `${title}
${note}`;
      if (!link.inline)
        this.markdown += `
${note}
`;
      this.markdown = this.markdown.replace(`[[${link.name}]]`, `[[#${link.name}]]`);
      if ("children" in link)
        this.composeMarkdown(link.children);
    });
  }
  cleanNote(link, note) {
    let noteRows = note.split("\n");
    const firstRow = fixSpaceInName(noteRows[0]);
    if (firstRow.includes(`# ${link.name}`)) {
      noteRows.shift();
      note = noteRows.join("\n").trim();
    }
    noteRows = note.split("\n");
    note = noteRows.reduce((acc, row) => {
      let val = acc + row;
      if (row.match(/^(#\w)+(.*)/)) {
        val = acc;
      }
      return val + "\n";
    }, "");
    const localHeading = note.matchAll(/#+\s+(.*)\n/g);
    [...localHeading].forEach(([raw, cl]) => {
      note = note.replace(raw, `###### ${cl.trim()}
`);
    });
    return note.trim();
  }
  transformTitle(link) {
    let title = "";
    if (link.inline) {
      title = `##### ${link.name}`;
    } else {
      const nestedLevel = Array(link.level).fill("#").join("");
      title = `${nestedLevel} ${link.name}`;
    }
    return title;
  }
  async generateNotesHierarchy(links) {
    const linksObj = await this.createParentStructure(links, 0, []);
    const linksArr = [];
    Object.keys(linksObj).forEach((key) => {
      var _a, _b;
      const { parentRef, ...rest } = linksObj[key];
      linksArr.push({ ...rest, parent: (_b = (_a = linksObj[key]) == null ? void 0 : _a.parentRef) == null ? void 0 : _b.name });
    });
    const buildChildrenFromParents = (arr, parent) => {
      let children = [];
      for (let i = 0; i < arr.length; i++) {
        if (arr[i].parent == parent) {
          const grandChildren = buildChildrenFromParents(arr, arr[i].name);
          if (grandChildren.length)
            arr[i].children = grandChildren;
          children.push(arr[i]);
        }
      }
      return children;
    };
    return buildChildrenFromParents(linksArr, void 0);
  }
  async createParentStructure(links, level, processed, parentRef, titleMapping) {
    titleMapping = titleMapping != null ? titleMapping : {};
    for await (const [order, link] of links.entries()) {
      if (this.mainNameLinks.includes(link.name) && level != 0)
        continue;
      if (processed.includes(link.name))
        continue;
      processed.push(link.name);
      let note = await getNoteByName(this.app, link.path);
      const subLinks = this.parseLinks(note);
      const incomplete = note.length <= 160 && !note.includes(this.settings.listOfLinksKeyword) ? true : false;
      this.maxLevel = level + 1;
      if (note.includes(this.settings.listOfLinksKeyword)) {
        let [importantPart, endPart] = note.split(this.settings.listOfLinksKeyword);
        note = importantPart.trim();
      }
      titleMapping[link.name] = { ...link, parentRef, level: this.maxLevel, order, note, incomplete };
      if (links.length > 0)
        await this.createParentStructure(subLinks, this.maxLevel, processed, titleMapping[link.name], titleMapping);
    }
    return titleMapping;
  }
  makeContentPreviewMD(links, previewContent = "") {
    links.forEach((link) => {
      if (link.exists && link.level) {
        if (this.ignoredLinks.includes(link.name))
          return;
        const tabs = Array(link.level - 1).fill("	").join("");
        previewContent += `${tabs}- [[#${link.name}]]
`;
      }
      if ("children" in link)
        previewContent += this.makeContentPreviewMD(link.children);
    });
    return previewContent;
  }
  insertToNearestNewLine(note, links) {
    let specialArr = [];
    const rows = note.split("\n");
    const emptyLines = [];
    rows.forEach((row, index2) => {
      if (row == "") {
        specialArr.push([]);
        emptyLines.push(index2);
      } else
        specialArr.push(row);
    });
    specialArr.push([]);
    emptyLines.push(specialArr.length - 1);
    links.forEach((link) => {
      const index2 = specialArr.findIndex((row) => typeof row === "string" && row.includes(`[[${link.name}]]`));
      const findClosestHigher = emptyLines.filter((candidate) => candidate > index2)[0];
      const title = this.transformTitle(link);
      let note2 = link.note.trim();
      if (note2.length == 0)
        return;
      if (this.ignoredLinks.includes(link.name))
        return;
      note2 = this.cleanNote(link, note2);
      specialArr[findClosestHigher].push(title, note2);
    });
    return specialArr.map((row) => typeof row === "string" ? row : row.join("\n")).join("\n").trim() + "\n";
  }
};
var GenerateMarkdown = _GenerateMarkdown;
GenerateMarkdown.imageTypes = ["jpg", "jpeg", "png", "gif", "webp", "tiff", "bmp"].map((it) => `.${it}`);

// src/views/notes-merger.ts
var VIEW_CONTENT_COMPOSE_NOTES = "view-notes-merger";
var NotesMerger = class extends import_obsidian6.ItemView {
  constructor(leaf, settings) {
    super(leaf);
    this.settings = settings;
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    this.container = container;
    container.empty();
    this.toolbar = container.createEl("div", { cls: "toolbar" });
    this.generateMarkdownTabParent = this.toolbar.createEl("div", { cls: "generate-markdown-tab-btn" });
    this.generateLatexTabParent = this.toolbar.createEl("div", { cls: "generate-latex-tab-btn" });
    this.subbar = container.createEl("div", { cls: "subbar" });
    this.structure = this.container.createEl("div");
    new Button(this.generateMarkdownTabParent, "Generate Merging Preview", () => {
      this.structure.empty();
      this.subbar.empty();
      const generateMarkdown = new GenerateMarkdown(app, this.settings, this.structure, this.subbar);
      generateMarkdown.readSelectedNote();
    });
    new Button(this.generateLatexTabParent, "Generate Latex", async () => {
      this.subbar.empty();
      new Button(this.subbar, "Generate Plain Latex", () => {
        this.structure.empty();
        const generateLatex = new GenerateLatex(this.app, this.settings, this.structure);
        generateLatex.renderLatexStatus(generateLatex);
      }, { cls: "generate-plain-latex-btn" });
      new Button(this.subbar, "Generate Latex With Template", () => {
        this.structure.empty();
        const generateLatex = new GenerateLatex(this.app, this.settings, this.structure);
        generateLatex.renderLatexWithTemplateStatus(generateLatex);
      }, { cls: "generate-template-latex-btn" });
    });
  }
  async onClose() {
  }
  getViewType() {
    return VIEW_CONTENT_COMPOSE_NOTES;
  }
  getDisplayText() {
    return "Notes Merger";
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  listOfLinksKeyword: "Next:",
  literatureNote: "Literature",
  insertPreviewContent: true,
  insertIndexNote: false,
  removeStatusTag: true,
  metadataNote: "Metadata",
  latexImagesDirectoryName: "images",
  attachmentsDir: "attachments"
};
var NotesMergerPlugin = class extends import_obsidian7.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new NotesMergerPluginSettingTab(this.app, this));
    this.registerView(VIEW_CONTENT_COMPOSE_NOTES, (leaf) => new NotesMerger(leaf, this.settings));
    this.addRibbonIcon("scroll", "Notes Merger", () => {
      this.activateNotesMergerView();
    });
  }
  async activateNotesMergerView() {
    if (!this.app.workspace.getLeavesOfType(VIEW_CONTENT_COMPOSE_NOTES).length) {
      await this.app.workspace.getRightLeaf(false).setViewState({
        type: VIEW_CONTENT_COMPOSE_NOTES,
        active: true
      });
    }
    this.app.workspace.revealLeaf(this.app.workspace.getLeavesOfType(VIEW_CONTENT_COMPOSE_NOTES)[0]);
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var NotesMergerPluginSettingTab = class extends import_obsidian7.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian7.Setting(containerEl).setName("List of links keyword").setDesc("Keyword to detect list of links to be subchapters at the end of note.").addText((text3) => text3.setPlaceholder('Defaults to "Next:"').setValue(this.plugin.settings.listOfLinksKeyword).onChange(async (value) => {
      this.plugin.settings.listOfLinksKeyword = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Include generated preview").setDesc("Insert preview structure at the beginning of the merged note.").addToggle((toggle) => toggle.setValue(this.plugin.settings.insertPreviewContent).onChange(async (value) => {
      this.plugin.settings.insertPreviewContent = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Include index note").setDesc("Insert index note text at the beginning of the merged note.").addToggle((toggle) => toggle.setValue(this.plugin.settings.insertIndexNote).onChange(async (value) => {
      this.plugin.settings.insertIndexNote = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Remove tags").setDesc("Remove tag information from notes.").addToggle((toggle) => toggle.setValue(this.plugin.settings.removeStatusTag).onChange(async (value) => {
      this.plugin.settings.removeStatusTag = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Literature note").setDesc("Name of the note with citations.").addText((text3) => text3.setPlaceholder('Defaults to "Literature"').setValue(this.plugin.settings.literatureNote).onChange(async (value) => {
      this.plugin.settings.literatureNote = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Metadata note").setDesc("Name of the note that contains metadata. Note should include title, acknowledgements, abstract (czech, english), keywords (czech, english), declaration.").addText((text3) => text3.setPlaceholder(`Defaults to "Metadata"`).setValue(this.plugin.settings.metadataNote).onChange(async (value) => {
      this.plugin.settings.metadataNote = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Name of image folder inside generated latex folder").setDesc("Includes images found in markdown.").addText((text3) => text3.setPlaceholder(`Defaults to "images"`).setValue(this.plugin.settings.latexImagesDirectoryName).onChange(async (value) => {
      this.plugin.settings.latexImagesDirectoryName = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Attachments").setDesc("Path to attachments folder. One note per one attachment.").addText((text3) => text3.setPlaceholder(`Defaults to "attachments"`).setValue(this.plugin.settings.attachmentsDir).onChange(async (value) => {
      this.plugin.settings.attachmentsDir = value;
      await this.plugin.saveSettings();
    }));
  }
};
/**
 * @license lucide v0.298.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
